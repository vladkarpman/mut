<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Approve Test - TEST_NAME_PLACEHOLDER</title>
    <!-- Material Design 3 - Typography & Icons -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;500;600;700&family=IBM+Plex+Mono:wght@400;500&display=swap" rel="stylesheet">
    <!-- Material Symbols Icons -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
    <!-- Material Web Components -->
    <script type="importmap">
        {
            "imports": {
                "@material/web/": "https://esm.run/@anthropic-ai/material-web/"
            }
        }
    </script>
    <script type="module">
        import '@material/web/button/filled-button.js';
        import '@material/web/button/outlined-button.js';
        import '@material/web/button/text-button.js';
        import '@material/web/button/filled-tonal-button.js';
        import '@material/web/iconbutton/icon-button.js';
        import '@material/web/textfield/outlined-text-field.js';
        import '@material/web/select/outlined-select.js';
        import '@material/web/select/select-option.js';
        import '@material/web/chips/chip-set.js';
        import '@material/web/chips/filter-chip.js';
        import '@material/web/dialog/dialog.js';
        import '@material/web/progress/circular-progress.js';
    </script>
    <style>
        :root {
            /* ═══════════════════════════════════════════════════════════
               Material Design 3 - Dark Theme
               Based on m3.material.io official dark theme
               ═══════════════════════════════════════════════════════════ */

            /* MD3 Primary - Purple accent (from m3.material.io) */
            --md-primary: #d0bcff;
            --md-primary-rgb: 208, 188, 255;
            --md-on-primary: #381e72;
            --md-primary-container: #4f378b;
            --md-on-primary-container: #eaddff;

            /* MD3 Secondary */
            --md-secondary: #ccc2dc;
            --md-on-secondary: #332d41;
            --md-secondary-container: #4a4458;
            --md-on-secondary-container: #e8def8;

            /* MD3 Tertiary */
            --md-tertiary: #efb8c8;
            --md-on-tertiary: #492532;
            --md-tertiary-container: #633b48;
            --md-on-tertiary-container: #ffd8e4;

            /* MD3 Surface colors - Dark mode surfaces */
            --md-surface: #141218;
            --md-surface-dim: #0e0d11;
            --md-surface-bright: #3b383e;
            --md-surface-container-lowest: #0a090d;
            --md-surface-container-low: #1a181d;
            --md-surface-container: #1e1c22;
            --md-surface-container-high: #282629;
            --md-surface-container-highest: #333137;
            --md-on-surface: #e6e1e5;
            --md-on-surface-variant: #cac4d0;
            --md-outline: #938f99;
            --md-outline-variant: #49454f;

            /* MD3 Inverse Surface */
            --md-inverse-surface: #e6e1e5;
            --md-inverse-on-surface: #313033;
            --md-inverse-primary: #6750a4;

            /* MD3 Error */
            --md-error: #f2b8b5;
            --md-on-error: #601410;
            --md-error-container: #8c1d18;
            --md-on-error-container: #f9dedc;

            /* Mapped variables for backward compatibility */
            --primary: var(--md-primary);
            --primary-hover: #e8d6ff;
            --primary-subtle: var(--md-surface-container);

            --bg-base: var(--md-surface-dim);
            --bg-primary: var(--md-surface);
            --bg-secondary: var(--md-surface-container-low);
            --bg-tertiary: var(--md-surface-container);
            --bg-elevated: var(--md-surface-container-high);
            --bg-hover: var(--md-surface-container-high);
            --bg-active: var(--md-surface-container-highest);

            --text-primary: var(--md-on-surface);
            --text-secondary: var(--md-on-surface-variant);
            --text-tertiary: var(--md-outline);
            --text-muted: var(--md-outline-variant);
            --text-inverse: var(--md-surface);

            --border-subtle: var(--md-outline-variant);
            --border-default: var(--md-outline-variant);
            --border-strong: var(--md-outline);
            --border-color: var(--border-default);

            --accent-color: var(--md-primary);
            --accent-hover: #e8d6ff;
            --accent-subtle: var(--md-primary-container);
            --accent-muted: rgba(208, 188, 255, 0.16);

            /* Status colors - MD3 dark mode */
            --pass-color: #a8d5a2;
            --pass-bg: rgba(168, 213, 162, 0.16);
            --fail-color: var(--md-error);
            --fail-bg: rgba(242, 184, 181, 0.16);
            --skip-color: var(--md-outline);
            --skip-bg: var(--md-surface-container);
            --warning-color: #ffb957;
            --warning-bg: rgba(255, 185, 87, 0.16);

            /* Action type colors - Distinctive for dark mode */
            --action-tap: var(--md-primary);
            --action-tap-bg: rgba(208, 188, 255, 0.16);
            --action-swipe: var(--md-tertiary);
            --action-swipe-bg: rgba(239, 184, 200, 0.16);
            --action-verify: #a8d5a2;
            --action-verify-bg: rgba(168, 213, 162, 0.16);
            --action-type: #90caf9;
            --action-type-bg: rgba(144, 202, 249, 0.16);
            --action-wait: #ffb957;
            --action-wait-bg: rgba(255, 185, 87, 0.16);

            /* Spacing */
            --space-1: 4px;
            --space-2: 8px;
            --space-3: 12px;
            --space-4: 16px;
            --space-5: 20px;
            --space-6: 24px;
            --space-8: 32px;

            /* Radius - Modern rounded */
            --radius-xs: 4px;
            --radius-sm: 6px;
            --radius-md: 8px;
            --radius-lg: 12px;
            --radius-xl: 16px;
            --radius-full: 9999px;

            /* Shadows - Subtle depth */
            --shadow-xs: 0 1px 2px rgba(0, 0, 0, 0.04);
            --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.06), 0 1px 2px rgba(0, 0, 0, 0.04);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.07), 0 2px 4px -1px rgba(0, 0, 0, 0.04);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.08), 0 4px 6px -2px rgba(0, 0, 0, 0.04);
            --shadow-focus: 0 0 0 3px var(--accent-muted);

            /* ═══════════════════════════════════════════════════════════
               MD3 Motion System - Expressive Easing Curves
               ═══════════════════════════════════════════════════════════ */

            /* MD3 Standard Easing - For most transitions */
            --md-easing-standard: cubic-bezier(0.2, 0, 0, 1);
            --md-easing-standard-accelerate: cubic-bezier(0.3, 0, 1, 1);
            --md-easing-standard-decelerate: cubic-bezier(0, 0, 0, 1);

            /* MD3 Emphasized Easing - For important transitions */
            --md-easing-emphasized: cubic-bezier(0.2, 0, 0, 1);
            --md-easing-emphasized-accelerate: cubic-bezier(0.3, 0, 0.8, 0.15);
            --md-easing-emphasized-decelerate: cubic-bezier(0.05, 0.7, 0.1, 1);

            /* MD3 Duration tokens */
            --md-duration-short1: 50ms;
            --md-duration-short2: 100ms;
            --md-duration-short3: 150ms;
            --md-duration-short4: 200ms;
            --md-duration-medium1: 250ms;
            --md-duration-medium2: 300ms;
            --md-duration-medium3: 350ms;
            --md-duration-medium4: 400ms;
            --md-duration-long1: 450ms;
            --md-duration-long2: 500ms;
            --md-duration-long3: 550ms;
            --md-duration-long4: 600ms;
            --md-duration-extra-long1: 700ms;
            --md-duration-extra-long2: 800ms;

            /* Legacy animation variables mapped to MD3 */
            --transition-fast: var(--md-duration-short3) var(--md-easing-standard);
            --transition-base: var(--md-duration-short4) var(--md-easing-standard);
            --transition-slow: var(--md-duration-medium2) var(--md-easing-emphasized);
            --transition-bounce: var(--md-duration-medium4) var(--md-easing-emphasized-decelerate);
        }

        /* Material Symbols configuration */
        .material-symbols-outlined {
            font-variation-settings:
                'FILL' 0,
                'wght' 500,
                'GRAD' 0,
                'opsz' 20;
            font-size: 18px;
            line-height: 1;
        }

        /* ═══════════════════════════════════════════════════════════
           MD3 Global Animations & Keyframes
           ═══════════════════════════════════════════════════════════ */

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(16px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeInScale {
            from {
                opacity: 0;
                transform: scale(0.92);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        @keyframes scaleIn {
            from {
                opacity: 0;
                transform: scale(0.95);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        @keyframes slideInFromRight {
            from {
                opacity: 0;
                transform: translateX(24px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes slideInFromLeft {
            from {
                opacity: 0;
                transform: translateX(-24px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        @keyframes shimmer {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }

        @keyframes rippleEffect {
            0% {
                transform: scale(0);
                opacity: 0.5;
            }
            100% {
                transform: scale(4);
                opacity: 0;
            }
        }

        @keyframes stateLayerPulse {
            0% { background-color: transparent; }
            50% { background-color: var(--accent-muted); }
            100% { background-color: transparent; }
        }

        /* MD3 Ripple Effect */
        .md-ripple {
            position: relative;
            overflow: hidden;
        }

        .md-ripple::after {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            pointer-events: none;
            background-image: radial-gradient(circle, var(--md-primary) 10%, transparent 10.01%);
            background-repeat: no-repeat;
            background-position: 50%;
            transform: scale(10, 10);
            opacity: 0;
            transition: transform 0.5s, opacity 0.8s;
        }

        .md-ripple:active::after {
            transform: scale(0, 0);
            opacity: 0.3;
            transition: 0s;
        }

        /* State layer for interactive elements */
        .md-state-layer {
            position: relative;
        }

        .md-state-layer::before {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: inherit;
            background-color: transparent;
            transition: background-color var(--md-duration-short3) var(--md-easing-standard);
            pointer-events: none;
        }

        .md-state-layer:hover::before {
            background-color: rgba(208, 188, 255, 0.08);
        }

        .md-state-layer:focus-visible::before {
            background-color: rgba(208, 188, 255, 0.12);
        }

        .md-state-layer:active::before {
            background-color: rgba(208, 188, 255, 0.12);
        }

        /* ═══════════════════════════════════════════════════════════
           MD3 Custom Dialog / Modal
           ═══════════════════════════════════════════════════════════ */
        .md-dialog-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.32);
            backdrop-filter: blur(4px);
            z-index: 5000;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            visibility: hidden;
            transition: opacity var(--md-duration-medium2) var(--md-easing-emphasized),
                        visibility var(--md-duration-medium2);
        }

        .md-dialog-overlay.open {
            opacity: 1;
            visibility: visible;
        }

        .md-dialog {
            background: var(--md-surface-container-high);
            border-radius: 28px;
            min-width: 280px;
            max-width: 560px;
            max-height: 90vh;
            overflow: hidden;
            box-shadow:
                0 8px 12px 6px rgba(0, 0, 0, 0.15),
                0 4px 4px rgba(0, 0, 0, 0.3);
            transform: scale(0.9) translateY(20px);
            opacity: 0;
            transition: transform var(--md-duration-medium3) var(--md-easing-emphasized-decelerate),
                        opacity var(--md-duration-medium2) var(--md-easing-emphasized);
        }

        .md-dialog-overlay.open .md-dialog {
            transform: scale(1) translateY(0);
            opacity: 1;
        }

        .md-dialog-header {
            padding: 24px 24px 16px;
        }

        .md-dialog-title {
            font-size: 1.5rem;
            font-weight: 400;
            color: var(--md-on-surface);
            margin: 0;
            line-height: 1.3;
        }

        .md-dialog-content {
            padding: 0 24px 24px;
            color: var(--md-on-surface-variant);
            font-size: 0.875rem;
            line-height: 1.5;
            max-height: 60vh;
            overflow-y: auto;
        }

        .md-dialog-actions {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            padding: 16px 24px 24px;
        }

        /* ═══════════════════════════════════════════════════════════
           MD3 Custom Select / Dropdown Menu
           ═══════════════════════════════════════════════════════════ */
        .md-select-wrapper {
            position: relative;
            display: inline-block;
        }

        .md-select-trigger {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: var(--md-surface-container-high);
            border: none;
            border-radius: 4px 4px 0 0;
            border-bottom: 1px solid var(--md-outline);
            color: var(--md-on-surface);
            font-size: 0.875rem;
            font-family: inherit;
            cursor: pointer;
            min-width: 120px;
            transition: all var(--md-duration-short3) var(--md-easing-standard);
        }

        .md-select-trigger:hover {
            background: var(--md-surface-container-highest);
        }

        .md-select-trigger:focus {
            outline: none;
            border-bottom: 2px solid var(--md-primary);
        }

        .md-select-trigger .md-select-value {
            flex: 1;
            text-align: left;
        }

        .md-select-trigger .md-select-arrow {
            transition: transform var(--md-duration-short3) var(--md-easing-standard);
        }

        .md-select-wrapper.open .md-select-trigger .md-select-arrow {
            transform: rotate(180deg);
        }

        .md-select-menu {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--md-surface-container);
            border-radius: 4px;
            box-shadow:
                0 3px 5px -1px rgba(0, 0, 0, 0.2),
                0 6px 10px 0 rgba(0, 0, 0, 0.14),
                0 1px 18px 0 rgba(0, 0, 0, 0.12);
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transform: scaleY(0.8);
            transform-origin: top;
            transition: opacity var(--md-duration-short4) var(--md-easing-emphasized),
                        transform var(--md-duration-short4) var(--md-easing-emphasized),
                        visibility var(--md-duration-short4);
            max-height: 256px;
            overflow-y: auto;
        }

        .md-select-wrapper.open .md-select-menu {
            opacity: 1;
            visibility: visible;
            transform: scaleY(1);
        }

        .md-select-option {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            color: var(--md-on-surface);
            font-size: 0.875rem;
            cursor: pointer;
            transition: background-color var(--md-duration-short2) var(--md-easing-standard);
            position: relative;
        }

        .md-select-option::before {
            content: '';
            position: absolute;
            inset: 0;
            background-color: transparent;
            transition: background-color var(--md-duration-short2) var(--md-easing-standard);
        }

        .md-select-option:hover::before {
            background-color: rgba(208, 188, 255, 0.08);
        }

        .md-select-option.selected {
            background: rgba(208, 188, 255, 0.12);
        }

        .md-select-option.selected::after {
            content: 'check';
            font-family: 'Material Symbols Outlined';
            color: var(--md-primary);
            margin-left: auto;
        }

        /* Native select styling override */
        select.md-filled-select {
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            background: var(--md-surface-container-high) url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='%23cac4d0'%3E%3Cpath d='M7 10l5 5 5-5z'/%3E%3C/svg%3E") no-repeat right 8px center;
            border: none;
            border-bottom: 1px solid var(--md-outline);
            border-radius: 4px 4px 0 0;
            padding: 12px 40px 12px 16px;
            color: var(--md-on-surface);
            font-size: 0.875rem;
            font-family: inherit;
            cursor: pointer;
            transition: all var(--md-duration-short3) var(--md-easing-standard);
            min-width: 140px;
        }

        select.md-filled-select:hover {
            background-color: var(--md-surface-container-highest);
        }

        select.md-filled-select:focus {
            outline: none;
            border-bottom: 2px solid var(--md-primary);
            background-color: var(--md-surface-container-highest);
        }

        select.md-filled-select option {
            background: var(--md-surface-container);
            color: var(--md-on-surface);
            padding: 12px 16px;
        }

        /* ═══════════════════════════════════════════════════════════
           MD3 Text Input Field (Filled variant)
           ═══════════════════════════════════════════════════════════ */
        .md-text-field {
            position: relative;
            display: flex;
            flex-direction: column;
        }

        .md-text-field-input {
            background: var(--md-surface-container-high);
            border: none;
            border-bottom: 1px solid var(--md-outline);
            border-radius: 4px 4px 0 0;
            padding: 20px 16px 8px;
            color: var(--md-on-surface);
            font-size: 1rem;
            font-family: inherit;
            transition: all var(--md-duration-short3) var(--md-easing-standard);
        }

        .md-text-field-input:hover {
            background: var(--md-surface-container-highest);
        }

        .md-text-field-input:focus {
            outline: none;
            border-bottom: 2px solid var(--md-primary);
            background: var(--md-surface-container-highest);
        }

        .md-text-field-label {
            position: absolute;
            left: 16px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--md-on-surface-variant);
            font-size: 1rem;
            pointer-events: none;
            transition: all var(--md-duration-short3) var(--md-easing-standard);
        }

        .md-text-field-input:focus + .md-text-field-label,
        .md-text-field-input:not(:placeholder-shown) + .md-text-field-label {
            top: 8px;
            transform: translateY(0);
            font-size: 0.75rem;
            color: var(--md-primary);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Plus Jakarta Sans', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.5;
            height: 100vh;
            overflow: hidden;
            font-feature-settings: 'cv02', 'cv03', 'cv04', 'cv11';
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            letter-spacing: -0.01em;
        }

        /* Monospace for code/data */
        .mono, code, .step-position, input[type="number"] {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.85em;
        }

        /* ═══════════════════════════════════════════════════════════
           MD3 Top App Bar
           ═══════════════════════════════════════════════════════════ */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 16px;
            min-height: 64px;
            background: var(--md-surface);
            border-bottom: none;
            position: relative;
            z-index: 100;
            animation: fadeIn var(--md-duration-medium1) var(--md-easing-emphasized-decelerate);
        }

        /* Subtle bottom divider */
        .header::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg,
                transparent 0%,
                var(--md-outline-variant) 10%,
                var(--md-outline-variant) 90%,
                transparent 100%
            );
            opacity: 0.5;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .header-center {
            display: flex;
            align-items: center;
            justify-content: center;
            flex: 1;
        }

        .header h1 {
            font-size: 1rem;
            font-weight: 500;
            margin: 0;
            letter-spacing: 0.02em;
            color: var(--md-on-surface);
            white-space: nowrap;
        }

        .header-meta {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 0.8125rem;
            color: var(--md-on-surface-variant);
            background: var(--md-surface-container);
            padding: 8px 16px;
            border-radius: 100px;
            border: 1px solid var(--md-outline-variant);
        }

        .header-meta-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .header-meta-item .material-symbols-outlined {
            font-size: 15px;
            opacity: 0.6;
        }

        .header-meta-divider {
            opacity: 0.25;
            font-size: 0.5rem;
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 12px;
            justify-content: flex-end;
        }

        /* Export Button - Minimal */
        .export-btn-minimal {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 16px;
            background: transparent;
            border: 1px solid var(--md-outline-variant);
            border-radius: 8px;
            color: var(--md-on-surface);
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .export-btn-minimal .material-symbols-outlined {
            font-size: 18px;
            opacity: 0.7;
        }

        .export-btn-minimal:hover {
            background: var(--md-surface-container-high);
            border-color: var(--md-outline);
        }

        .export-btn-minimal:active {
            background: var(--md-surface-container-highest);
        }

        .btn-small {
            padding: 8px 16px;
            font-size: 0.875rem;
            min-height: 32px;
        }

        .btn {
            padding: 10px 24px;
            border-radius: 100px;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all var(--md-duration-short3) var(--md-easing-standard);
            border: none;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            letter-spacing: 0.01em;
            min-height: 40px;
            position: relative;
            overflow: hidden;
            text-decoration: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        /* MD3 Filled Button (Primary) */
        .btn-primary {
            background: var(--md-primary);
            color: var(--md-on-primary);
            font-weight: 500;
            border: none;
            border-radius: 100px;
            box-shadow: none;
        }

        .btn-primary::before {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: inherit;
            background-color: transparent;
            transition: background-color var(--md-duration-short3) var(--md-easing-standard);
        }

        .btn-primary:hover::before {
            background-color: rgba(255, 255, 255, 0.08);
        }

        .btn-primary:hover {
            box-shadow: 0 1px 3px 1px rgba(0, 0, 0, 0.15), 0 1px 2px rgba(0, 0, 0, 0.3);
        }

        .btn-primary:active::before {
            background-color: rgba(255, 255, 255, 0.12);
        }

        .btn-primary:focus-visible {
            outline: none;
            box-shadow: 0 0 0 3px var(--accent-muted);
        }

        /* MD3 Outlined Button (Secondary) */
        .btn-secondary {
            background: transparent;
            color: var(--md-primary);
            border: 1px solid var(--md-outline);
            border-radius: 100px;
        }

        .btn-secondary::before {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: inherit;
            background-color: transparent;
            transition: background-color var(--md-duration-short3) var(--md-easing-standard);
        }

        .btn-secondary:hover::before {
            background-color: rgba(208, 188, 255, 0.08);
        }

        .btn-secondary:active::before {
            background-color: rgba(208, 188, 255, 0.12);
        }

        .btn-secondary:focus-visible {
            outline: none;
            box-shadow: 0 0 0 3px var(--accent-muted);
        }

        /* MD3 Filled Tonal Button */
        .btn-tonal {
            background: var(--md-secondary-container);
            color: var(--md-on-secondary-container);
            border: none;
            border-radius: 100px;
        }

        .btn-tonal::before {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: inherit;
            background-color: transparent;
            transition: background-color var(--md-duration-short3) var(--md-easing-standard);
        }

        .btn-tonal:hover::before {
            background-color: rgba(208, 188, 255, 0.08);
        }

        .btn-tonal:hover {
            box-shadow: 0 1px 3px 1px rgba(0, 0, 0, 0.15), 0 1px 2px rgba(0, 0, 0, 0.3);
        }

        /* MD3 Text Button */
        .btn-text {
            background: transparent;
            color: var(--md-primary);
            border: none;
            padding: 10px 12px;
            border-radius: 100px;
        }

        .btn-text::before {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: inherit;
            background-color: transparent;
            transition: background-color var(--md-duration-short3) var(--md-easing-standard);
        }

        .btn-text:hover::before {
            background-color: rgba(208, 188, 255, 0.08);
        }

        .btn-verify {
            background: rgba(139, 92, 246, 0.2);
            color: var(--action-verify);
            border: 1px solid rgba(139, 92, 246, 0.4);
        }

        .btn-verify:hover {
            background: rgba(139, 92, 246, 0.3);
        }

        .step-add-actions {
            display: flex;
            gap: 10px;
            padding: 4px 0 8px 0;
            margin: 0 12px;
        }

        .btn-action-add {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 6px 14px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.15s;
        }

        .btn-action-add:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border-color: var(--text-secondary);
        }

        .btn-danger {
            background: var(--fail-color);
            color: white;
        }

        /* Main Layout - Two Panels */
        .main {
            display: flex;
            height: calc(100vh - 65px);
        }

        .video-panel {
            width: 25%;
            min-width: 240px;
            max-width: 320px;
            padding: 12px;
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            transition: all 0.3s ease;
        }

        .video-panel.collapsed {
            display: none;
        }

        .video-panel {
            position: relative;
        }

        .add-step-buttons {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }

        .add-step-buttons .btn {
            flex: 1;
        }

        .steps-panel {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        /* Video Player */
        .video-container {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .video-wrapper {
            display: flex;
            align-items: flex-start;
            justify-content: center;
            background: var(--bg-secondary);
            border-radius: 8px;
        }

        .video-wrapper video {
            width: 100%;
            height: 100%;
            object-fit: contain;
            border-radius: 8px;
        }

        .video-wrapper {
            position: relative;
        }

        .video-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            cursor: crosshair;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            z-index: 10;
        }

        .overlay-message {
            background: var(--accent-color);
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 500;
            pointer-events: none;
        }

        .direction-picker {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            background: var(--bg-secondary);
            padding: 12px;
            border-radius: 12px;
            border: 2px solid var(--accent-color);
        }

        .direction-picker .direction-row {
            display: flex;
            gap: 24px;
        }

        .direction-picker button {
            width: 48px;
            height: 48px;
            font-size: 1.5rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.15s;
        }

        .direction-picker button:hover {
            background: var(--accent-color);
            transform: scale(1.1);
        }

        /* MD3 Add Step Button - FAB Extended Style */
        .btn-add-step {
            width: 100%;
            margin-top: var(--space-4);
            padding: 14px 20px;
            background: var(--md-surface-container-high);
            color: var(--md-primary);
            border: none;
            border-radius: 16px;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all var(--md-duration-short3) var(--md-easing-standard);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            position: relative;
            overflow: hidden;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.15);
        }

        .btn-add-step::before {
            content: '';
            position: absolute;
            inset: 0;
            background-color: transparent;
            transition: background-color var(--md-duration-short3) var(--md-easing-standard);
        }

        .btn-add-step:hover {
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.25);
        }

        .btn-add-step:hover::before {
            background-color: rgba(208, 188, 255, 0.08);
        }

        .btn-add-step:active::before {
            background-color: rgba(208, 188, 255, 0.12);
        }

        /* === ADD STEP MODE === */
        .add-step-mode {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--bg-primary);
            z-index: 2000;
            display: none;
            flex-direction: column;
            animation: fadeIn 0.2s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .add-step-mode.active {
            display: flex;
        }

        .add-step-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 32px;
            background: var(--md-surface-container);
            border-bottom: 1px solid var(--md-outline-variant);
        }

        .add-step-header h2 {
            font-size: 1.25rem;
            font-weight: 500;
            margin: 0;
            color: var(--md-on-surface);
            letter-spacing: -0.01em;
        }

        .add-step-header-actions {
            display: flex;
            gap: 12px;
        }

        .add-step-header-actions .btn {
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 0.875rem;
            font-weight: 500;
        }

        .add-step-header-actions .btn-secondary {
            background: transparent;
            border: 1px solid var(--md-outline);
            color: var(--md-on-surface);
        }

        .add-step-header-actions .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.08);
        }

        .add-step-header-actions .btn-primary {
            background: var(--md-primary);
            border: none;
            color: var(--md-on-primary);
        }

        .add-step-header-actions .btn-primary:hover:not(:disabled) {
            background: var(--primary-hover);
        }

        .add-step-header-actions .btn-primary:disabled {
            background: var(--md-surface-container-highest);
            color: var(--md-outline);
            cursor: not-allowed;
        }

        .add-step-body {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        .add-step-video-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            background: var(--bg-primary);
            min-height: 0; /* Allow flex shrinking */
            overflow: hidden;
        }

        .add-step-video-container {
            position: relative;
            max-height: calc(100vh - 180px);
            display: inline-flex;
            flex-direction: column;
            align-items: stretch;
        }

        .add-step-video-wrapper {
            position: relative;
            background: #000;
            border-radius: 12px 12px 0 0;
            overflow: hidden;
        }

        .add-step-video-wrapper video {
            max-height: calc(100vh - 280px);
            width: auto;
            display: block;
        }

        .add-step-video-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            cursor: crosshair;
        }

        .add-step-video-overlay.inactive {
            cursor: default;
            pointer-events: none;
        }

        /* Custom video controls */
        .add-step-video-controls {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px 16px;
            background: var(--bg-secondary);
            border-radius: 0 0 12px 12px;
            width: 100%;
            box-sizing: border-box;
        }

        .video-play-btn {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: var(--accent-color);
            border: none;
            color: white;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .video-play-btn:hover {
            background: var(--accent-hover);
        }

        .video-scrubber {
            flex: 1;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: var(--bg-tertiary);
            border-radius: 3px;
            cursor: pointer;
        }

        .video-scrubber::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--accent-color);
            cursor: pointer;
        }

        .video-scrubber::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--accent-color);
            cursor: pointer;
            border: none;
        }

        .video-time {
            font-size: 0.8rem;
            color: var(--text-secondary);
            font-family: monospace;
            white-space: nowrap;
        }

        /* Frame type selector */
        .add-step-frame-type {
            margin-top: 12px;
        }

        .frame-type-buttons {
            display: flex;
            gap: 8px;
        }

        .frame-type-btn {
            flex: 1;
            padding: 8px 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-secondary);
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.15s;
        }

        .frame-type-btn:hover {
            background: var(--bg-primary);
            border-color: var(--accent-color);
        }

        .frame-type-btn.selected {
            background: var(--accent-color);
            border-color: var(--accent-color);
            color: white;
        }

        .add-step-tap-indicator {
            position: absolute;
            width: 36px;
            height: 36px;
            border: 3px solid var(--action-tap);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            box-shadow: 0 0 15px rgba(245, 158, 11, 0.6);
            animation: pulse-tap 1.5s ease-in-out infinite;
        }

        @keyframes pulse-tap {
            0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 0.7; }
        }

        .add-step-swipe-indicator {
            position: absolute;
            pointer-events: none;
        }

        .add-step-swipe-start {
            width: 24px;
            height: 24px;
            border: 3px solid var(--action-swipe);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 10px rgba(245, 158, 11, 0.5);
        }

        .add-step-instruction {
            margin-top: 16px;
            text-align: center;
            color: var(--text-secondary);
            font-size: 0.95rem;
        }

        .add-step-instruction.highlight {
            color: var(--accent-color);
            font-weight: 500;
        }

        .add-step-sidebar {
            width: 320px;
            background: var(--bg-secondary);
            border-left: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        .add-step-sidebar-section {
            padding: 20px;
            border-bottom: 1px solid var(--border-color);
        }

        .add-step-sidebar-section:last-child {
            border-bottom: none;
        }

        .add-step-sidebar-section h3 {
            font-size: 0.8rem;
            text-transform: uppercase;
            color: var(--text-secondary);
            margin-bottom: 12px;
            letter-spacing: 0.5px;
        }

        .add-step-type-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        /* MD3 Filter Chip style buttons */
        .add-step-type-btn {
            display: inline-flex;
            align-items: center;
            gap: var(--space-2);
            padding: 8px 16px;
            background: transparent;
            border: 1px solid var(--md-outline);
            border-radius: 8px;
            cursor: pointer;
            transition: all var(--transition-fast);
            font-family: inherit;
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--md-on-surface);
        }

        .add-step-type-btn:hover {
            background: var(--accent-muted);
        }

        .add-step-type-btn:active {
            background: rgba(208, 188, 255, 0.24);
        }

        .add-step-type-btn.selected {
            background: var(--md-secondary-container);
            border-color: transparent;
            color: var(--md-on-secondary-container);
        }

        .add-step-type-btn.selected:hover {
            background: rgba(204, 194, 220, 0.32);
        }

        .add-step-type-btn .material-symbols-outlined {
            font-size: 18px;
            color: inherit;
        }

        .add-step-type-btn .icon {
            font-size: 1rem;
            line-height: 1;
        }

        .add-step-type-btn .label {
            font-weight: 500;
        }

        .add-step-type-btn.selected .label {
            color: inherit;
        }

        .add-step-input-section {
            display: none;
        }

        .add-step-input-section.active {
            display: block;
        }

        /* Optional toggle for condition/verification in Add Step */
        .add-step-optional-toggle {
            margin-bottom: 8px;
        }

        .add-step-optional-toggle label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            color: var(--text-secondary);
            font-size: 0.85rem;
        }

        .add-step-optional-toggle input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        .add-step-input {
            width: 100%;
            padding: 10px 12px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 0.9rem;
            margin-top: 8px;
        }

        .add-step-input:focus {
            outline: none;
            border-color: var(--accent-color);
        }

        .add-step-direction-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            margin-top: 12px;
        }

        .add-step-direction-btn {
            padding: 10px;
            background: var(--bg-tertiary);
            border: 2px solid transparent;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1.2rem;
            transition: all 0.15s;
        }

        .add-step-direction-btn:hover {
            background: var(--bg-primary);
        }

        .add-step-direction-btn.selected {
            background: rgba(59, 130, 246, 0.2);
            border-color: var(--accent-color);
        }

        .add-step-position-info {
            display: none;
            padding: 12px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            margin-top: 12px;
        }

        .add-step-position-info.active {
            display: block;
        }

        .add-step-position-info .label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            text-transform: uppercase;
        }

        .add-step-position-info .value {
            font-size: 1rem;
            font-weight: 500;
            color: var(--text-primary);
            margin-top: 4px;
        }

        .add-step-position-info .btn-reset {
            margin-top: 8px;
            width: 100%;
            padding: 6px 12px;
            font-size: 0.8rem;
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
        }

        .add-step-position-info .btn-reset:hover {
            background: var(--bg-primary);
            border-color: var(--accent-color);
            color: var(--text-primary);
        }

        /* ========================================
           3-Column Add Step Layout - MD3 Styled
           Matches main step card layout
           ======================================== */

        .add-step-top-bar {
            display: flex;
            align-items: center;
            gap: 32px;
            padding: 16px 32px;
            background: var(--md-surface-container-low);
            border-bottom: 1px solid var(--md-outline-variant);
        }

        .add-step-top-section {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .add-step-top-section label {
            font-size: 0.8125rem;
            font-weight: 500;
            color: var(--md-on-surface-variant);
            white-space: nowrap;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .add-step-select {
            padding: 12px 16px;
            padding-right: 40px;
            background: var(--md-surface-container-high);
            border: 1px solid var(--md-outline);
            border-radius: 8px;
            color: var(--md-on-surface);
            font-size: 0.9375rem;
            min-width: 220px;
            cursor: pointer;
            transition: all var(--md-duration-short3) var(--md-easing-standard);
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='%23cac4d0'%3E%3Cpath d='M7 10l5 5 5-5z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 8px center;
        }

        .add-step-select:hover {
            border-color: var(--md-on-surface);
            background-color: var(--md-surface-container-highest);
        }

        .add-step-select:focus {
            outline: none;
            border-color: var(--md-primary);
            border-width: 2px;
            padding: 11px 15px;
            padding-right: 39px;
        }

        .add-step-select option {
            background: var(--md-surface-container-high);
            color: var(--md-on-surface);
            padding: 12px 16px;
            font-size: 0.9375rem;
        }

        .add-step-type-buttons {
            display: flex;
            gap: 8px;
        }

        .add-step-type-buttons .add-step-type-btn {
            padding: 10px 18px;
            font-size: 0.875rem;
            flex-direction: row;
            gap: 8px;
            border-radius: 20px;
            background: var(--md-surface-container-high);
            border: 1px solid var(--md-outline-variant);
            color: var(--md-on-surface);
            cursor: pointer;
            transition: all var(--md-duration-short3) var(--md-easing-standard);
        }

        .add-step-type-buttons .add-step-type-btn:hover {
            background: var(--md-surface-container-highest);
            border-color: var(--md-on-surface);
        }

        .add-step-type-buttons .add-step-type-btn.selected {
            background: var(--md-primary-container);
            border-color: var(--md-primary);
            color: var(--md-on-primary-container);
        }

        /* Video area - centered above columns */
        .add-step-video-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 16px 20px;
            background: var(--bg-primary);
            border-bottom: 1px solid var(--border-color);
        }

        .add-step-video-area .add-step-video-wrapper {
            max-width: 400px;
            width: 100%;
        }

        .add-step-video-area .add-step-video-wrapper video {
            width: 100%;
            max-height: 300px;
            object-fit: contain;
        }

        .add-step-video-area .add-step-video-controls {
            max-width: 400px;
            width: 100%;
        }

        /* 3-Column layout - matches main step frames */
        .add-step-columns {
            display: flex;
            flex: 1;
            gap: 20px;
            padding: 24px 32px;
            background: var(--md-surface);
            overflow: hidden;
        }

        .add-step-column {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--md-surface-container);
            border-radius: 16px;
            overflow: hidden;
            min-width: 0;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
            transition: all var(--md-duration-short3) var(--md-easing-standard);
        }

        /* Column variants - matching main layout */
        .add-step-column.before {
            border: 1px solid var(--md-outline-variant);
        }

        .add-step-column.action {
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4), 0 0 0 2px var(--md-primary-container);
            z-index: 1;
        }

        .add-step-column.after {
            border: 1px solid var(--md-outline-variant);
        }

        /* Column headers - matching main layout */
        .add-step-column-header {
            padding: 14px 16px;
            text-align: center;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            border-radius: 16px 16px 0 0;
        }

        .add-step-column.before .add-step-column-header {
            background: var(--md-surface-container-high);
            color: var(--md-on-surface-variant);
            border-bottom: 1px solid var(--md-outline-variant);
        }

        .add-step-column.action .add-step-column-header {
            background: var(--md-primary-container);
            color: var(--md-on-primary-container);
            font-weight: 700;
            letter-spacing: 0.12em;
        }

        .add-step-column.after .add-step-column-header {
            background: rgba(168, 213, 162, 0.25);
            color: var(--pass-color);
            border-bottom: 1px solid rgba(168, 213, 162, 0.3);
        }

        /* Frame preview box - LARGE images */
        .add-step-frame-preview {
            position: relative;
            width: 100%;
            min-height: 280px;
            background: var(--md-surface-dim);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            overflow: hidden;
            transition: all var(--md-duration-short3) var(--md-easing-standard);
        }

        .add-step-frame-preview:hover {
            background: var(--md-surface-container-low);
        }

        .add-step-frame-preview.captured {
            background: #000;
            min-height: 0;
        }

        .add-step-frame-preview img {
            width: 100%;
            height: auto;
            display: block;
        }

        .add-step-frame-preview .capture-hint {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            font-size: 0.875rem;
            color: var(--md-on-surface-variant);
            text-align: center;
            padding: 24px;
        }

        .add-step-frame-preview .capture-hint::before {
            content: 'add_photo_alternate';
            font-family: 'Material Symbols Outlined';
            font-size: 48px;
            color: var(--md-outline);
        }

        .add-step-frame-preview.captured .capture-hint {
            display: none;
        }

        /* Tap indicator inside action frame preview - high contrast */
        .add-step-frame-preview .add-step-tap-indicator {
            position: absolute;
            width: 36px;
            height: 36px;
            background: var(--md-primary);
            border: 3px solid #fff;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            box-shadow:
                0 0 0 2px rgba(0, 0, 0, 0.8),
                0 4px 12px rgba(0, 0, 0, 0.5),
                0 0 20px rgba(208, 188, 255, 0.6);
            animation: tapBounce 1.5s cubic-bezier(0.34, 1.56, 0.64, 1) infinite;
        }

        /* Swipe indicators in Add Step preview */
        .add-step-frame-preview .add-step-swipe-indicator {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            box-shadow:
                0 0 0 2px rgba(0, 0, 0, 0.8),
                0 2px 8px rgba(0, 0, 0, 0.5);
        }

        .add-step-frame-preview .add-step-swipe-indicator.start {
            background: var(--md-tertiary);
            border: 2px solid #fff;
        }

        .add-step-frame-preview .add-step-swipe-indicator.end {
            background: var(--md-primary);
            border: 2px solid #fff;
        }

        /* Column content area */
        .add-step-column-content {
            padding: 8px 10px;
            padding-bottom: 12px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        /* Description input - MD3 outlined style with floating label (matches main page) */
        .add-step-desc-wrapper {
            position: relative;
            margin: 0;
        }

        .add-step-desc-input {
            width: 100%;
            padding: 12px 14px;
            padding-top: 18px;
            background: transparent;
            border: 1px solid var(--md-outline);
            border-radius: 8px;
            color: var(--md-on-surface);
            font-size: 0.875rem;
            line-height: 1.5;
            min-height: 48px;
            transition: all var(--md-duration-short3) var(--md-easing-standard);
            box-sizing: border-box;
        }

        .add-step-desc-wrapper::before {
            content: 'Description';
            position: absolute;
            top: -8px;
            left: 10px;
            padding: 0 4px;
            background: var(--md-surface-container);
            font-size: 0.6875rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--md-on-surface-variant);
            z-index: 1;
        }

        .add-step-desc-input:hover {
            border-color: var(--md-on-surface);
            background: rgba(255, 255, 255, 0.02);
        }

        .add-step-desc-input:focus {
            outline: none;
            border-color: var(--md-primary);
            border-width: 2px;
            padding: 11px 13px;
            padding-top: 17px;
        }

        .add-step-desc-input::placeholder {
            color: var(--md-on-surface-variant);
            opacity: 0.6;
            font-style: italic;
        }

        /* Condition/Verification option sections - matches main page btn-add-inline */
        .add-step-column-option {
            margin-top: 0;
        }

        .btn-add-option {
            width: 100%;
            padding: 12px 16px;
            background: transparent;
            border: 1px dashed var(--md-outline);
            border-radius: 8px;
            color: var(--md-on-surface-variant);
            font-size: 0.8125rem;
            font-weight: 500;
            letter-spacing: 0.02em;
            cursor: pointer;
            transition: all var(--md-duration-short3) var(--md-easing-standard);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            position: relative;
            overflow: hidden;
        }

        .btn-add-option .material-symbols-outlined {
            font-size: 18px;
        }

        .btn-add-option::after {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: inherit;
            background-color: transparent;
            transition: background-color var(--md-duration-short3) var(--md-easing-standard);
            pointer-events: none;
        }

        .btn-add-option:hover {
            border-style: solid;
            border-color: var(--md-on-surface);
            color: var(--md-on-surface);
        }

        .btn-add-option:hover::after {
            background-color: rgba(255, 255, 255, 0.04);
        }

        .btn-add-option:active::after {
            background-color: rgba(255, 255, 255, 0.08);
        }

        .btn-add-option.active {
            border-style: solid;
        }

        /* Condition button - warning/amber color (matches main page) */
        .add-step-column.before .btn-add-option {
            border-color: rgba(255, 185, 87, 0.4);
            color: var(--warning-color);
        }

        .add-step-column.before .btn-add-option:hover {
            border-color: var(--warning-color);
        }

        .add-step-column.before .btn-add-option:hover::after {
            background-color: rgba(255, 185, 87, 0.08);
        }

        .add-step-column.before .btn-add-option:active::after {
            background-color: rgba(255, 185, 87, 0.12);
        }

        .add-step-column.before .btn-add-option.active {
            border-color: var(--warning-color);
            background: rgba(255, 185, 87, 0.12);
        }

        /* Verification button - success/green color (matches main page) */
        .add-step-column.after .btn-add-option {
            border-color: rgba(168, 213, 162, 0.4);
            color: var(--pass-color);
        }

        .add-step-column.after .btn-add-option:hover {
            border-color: var(--pass-color);
        }

        .add-step-column.after .btn-add-option:hover::after {
            background-color: rgba(168, 213, 162, 0.08);
        }

        .add-step-column.after .btn-add-option:active::after {
            background-color: rgba(168, 213, 162, 0.12);
        }

        .add-step-column.after .btn-add-option.active {
            border-color: var(--pass-color);
            background: rgba(168, 213, 162, 0.12);
        }

        .add-step-option-fields {
            margin-top: 12px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .add-step-mini-select {
            width: 100%;
            padding: 12px 14px;
            background: var(--md-surface-container-high);
            border: 1px solid var(--md-outline);
            border-radius: 8px;
            color: var(--md-on-surface);
            font-size: 0.875rem;
            cursor: pointer;
            transition: all var(--md-duration-short3) var(--md-easing-standard);
        }

        .add-step-mini-input {
            width: 100%;
            padding: 12px 14px;
            background: transparent;
            border: 1px solid var(--md-outline);
            border-radius: 8px;
            color: var(--md-on-surface);
            font-size: 0.875rem;
            transition: all var(--md-duration-short3) var(--md-easing-standard);
        }

        .add-step-mini-input:hover,
        .add-step-mini-select:hover {
            border-color: var(--md-on-surface);
        }

        .add-step-mini-input:focus,
        .add-step-mini-select:focus {
            outline: none;
            border-color: var(--md-primary);
            border-width: 2px;
            padding: 11px 13px;
        }

        /* Action controls in middle column */
        .add-step-action-controls {
            margin: 12px 10px 16px;
            padding: 0;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .add-step-action-controls .add-step-mini-input {
            margin: 0;
        }

        .add-step-position-display {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 14px;
            background: var(--md-surface-container-high);
            border-radius: 8px;
            border: 1px solid var(--md-outline-variant);
        }

        .add-step-position-display .label {
            font-size: 0.75rem;
            font-weight: 500;
            color: var(--md-on-surface-variant);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .add-step-position-display .value {
            font-size: 0.9375rem;
            color: var(--md-on-surface);
            font-family: 'IBM Plex Mono', monospace;
            font-weight: 500;
        }

        /* Checkbox label for type action */
        .add-step-checkbox-label {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 0;
            padding: 10px 14px;
            background: var(--md-surface-container-high);
            border-radius: 8px;
            border: 1px solid var(--md-outline-variant);
            cursor: pointer;
            font-size: 0.875rem;
            color: var(--md-on-surface-variant);
            transition: all var(--md-duration-short3) var(--md-easing-standard);
        }

        .add-step-checkbox-label:hover {
            background: var(--md-surface-container-highest);
            color: var(--md-on-surface);
        }

        .add-step-checkbox-label input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--md-primary);
            cursor: pointer;
        }

        /* Direction buttons for swipe */
        .add-step-direction-buttons {
            display: flex;
            gap: 8px;
            margin: 0;
            justify-content: center;
        }

        .dir-btn {
            width: 48px;
            height: 48px;
            background: var(--md-surface-container-high);
            border: 1px solid var(--md-outline-variant);
            border-radius: 12px;
            color: var(--md-on-surface);
            cursor: pointer;
            transition: all var(--md-duration-short3) var(--md-easing-standard);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .dir-btn:hover {
            background: var(--md-surface-container-highest);
            border-color: var(--md-on-surface);
        }

        .dir-btn.selected {
            background: var(--md-primary-container);
            border-color: var(--md-primary);
            color: var(--md-on-primary-container);
        }

        .dir-btn.selected {
            background: rgba(245, 158, 11, 0.2);
            border-color: var(--action-swipe);
        }

        /* Instruction bar for Add Step */
        .add-step-instruction-bar {
            text-align: center;
            padding: 16px 32px;
            color: var(--md-on-surface-variant);
            font-size: 0.9375rem;
            background: var(--md-surface-dim);
            border-bottom: 1px solid var(--md-outline-variant);
            margin: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
        }

        .add-step-instruction-bar::before {
            content: 'info';
            font-family: 'Material Symbols Outlined';
            font-size: 20px;
            color: var(--md-primary);
        }

        /* ========================================
           Frame Picker Modal - Redesigned
           ======================================== */

        .frame-picker-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(12px);
            z-index: 3000;
            align-items: center;
            justify-content: center;
        }

        .frame-picker-modal.active {
            display: flex;
        }

        .frame-picker-content {
            background: var(--md-surface-container);
            border-radius: 28px;
            max-width: 900px;
            width: 95%;
            max-height: 95vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow:
                0 8px 32px rgba(0, 0, 0, 0.4),
                0 0 0 1px rgba(255, 255, 255, 0.05);
            animation: fadeInScale var(--md-duration-medium3) var(--md-easing-emphasized-decelerate);
        }

        /* Header */
        .frame-picker-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 24px;
            background: var(--md-surface-container-high);
            border-bottom: 1px solid var(--md-outline-variant);
        }

        .frame-picker-header-left {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .frame-picker-header h3 {
            margin: 0;
            font-size: 1.375rem;
            font-weight: 500;
            color: var(--md-on-surface);
        }

        .frame-picker-close {
            width: 40px;
            height: 40px;
            background: transparent;
            border: none;
            border-radius: 20px;
            color: var(--md-on-surface-variant);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all var(--md-duration-short3) var(--md-easing-standard);
        }

        .frame-picker-close:hover {
            background: rgba(255, 255, 255, 0.08);
            color: var(--md-on-surface);
        }

        /* Body */
        .frame-picker-body {
            padding: 20px 24px;
            flex: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        /* Instruction hint for action frames */
        .frame-picker-hint {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px 16px;
            background: var(--md-surface-container-high);
            border-radius: 12px;
            border: 1px solid var(--md-outline-variant);
            font-size: 0.875rem;
            color: var(--md-on-surface-variant);
        }

        .frame-picker-hint .material-symbols-outlined {
            color: var(--md-primary);
            font-size: 20px;
        }

        /* Video container */
        .frame-picker-video-container {
            position: relative;
            background: #000;
            border-radius: 0;
            overflow: hidden;
            margin: 0 -24px; /* Extend to full width */
            width: calc(100% + 48px);
        }

        .frame-picker-video-container video {
            width: 100%;
            max-height: 60vh; /* Use viewport height for tall mobile screens */
            display: block;
            object-fit: contain;
            background: #000;
        }

        .frame-picker-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            cursor: crosshair;
        }

        .frame-picker-overlay.inactive {
            cursor: pointer;
            pointer-events: auto;
        }

        .frame-picker-tap-indicator {
            position: absolute;
            width: 36px;
            height: 36px;
            background: var(--md-primary);
            border: 3px solid #fff;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            box-shadow:
                0 0 0 2px rgba(0, 0, 0, 0.8),
                0 4px 12px rgba(0, 0, 0, 0.5),
                0 0 20px rgba(208, 188, 255, 0.6);
            animation: tapPulse 1.5s ease-in-out infinite;
        }

        /* Swipe indicators */
        .frame-picker-swipe-indicator {
            position: absolute;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow:
                0 0 0 2px rgba(0, 0, 0, 0.8),
                0 4px 12px rgba(0, 0, 0, 0.5);
        }

        .frame-picker-swipe-indicator.start {
            background: var(--md-tertiary);
            border: 3px solid #fff;
        }

        .frame-picker-swipe-indicator.end {
            background: var(--md-primary);
            border: 3px solid #fff;
        }

        .frame-picker-swipe-indicator .swipe-label {
            position: absolute;
            top: -20px;
            font-size: 0.625rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #fff;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.8);
            white-space: nowrap;
        }

        /* Swipe line SVG */
        .frame-picker-swipe-line {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: visible;
        }

        @keyframes tapPulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            50% { transform: translate(-50%, -50%) scale(1.1); opacity: 0.9; }
        }

        /* Time badge */
        .video-time-badge {
            position: absolute;
            bottom: 12px;
            left: 12px;
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 6px 12px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(8px);
            border-radius: 6px;
            font-size: 0.875rem;
            font-family: 'IBM Plex Mono', monospace;
            font-weight: 500;
            color: #fff;
        }

        .video-time-badge .time-separator {
            color: rgba(255, 255, 255, 0.5);
        }

        .video-time-badge .frame-number {
            color: var(--md-primary);
            font-weight: 600;
        }

        /* Play state indicator */
        .video-play-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 64px;
            height: 64px;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(8px);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.2s ease;
            pointer-events: none;
        }

        .video-play-indicator .material-symbols-outlined {
            font-size: 32px;
            color: #fff;
        }

        .video-play-indicator.show {
            opacity: 1;
        }

        /* Scrubber timeline */
        .frame-picker-scrubber {
            padding: 0;
            margin: 0 -24px; /* Extend to full width */
            width: calc(100% + 48px);
        }

        .scrubber-track {
            position: relative;
            height: 48px;
            background: var(--md-surface-container-high);
            border-radius: 0;
            cursor: pointer;
            overflow: visible;
        }

        .scrubber-progress {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            background: linear-gradient(90deg,
                rgba(208, 188, 255, 0.3) 0%,
                rgba(208, 188, 255, 0.15) 100%);
            pointer-events: none;
            transition: width 0.05s linear;
            border-radius: 0;
        }

        .scrubber-thumb {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: var(--md-primary);
            pointer-events: none;
            transition: left 0.05s linear;
        }

        .scrubber-markers {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: flex;
            pointer-events: none;
        }

        .scrubber-marker {
            position: absolute;
            top: 4px;
            bottom: 4px;
            width: 40px;
            transform: translateX(-50%);
            border-radius: 4px;
            overflow: hidden;
            opacity: 0.6;
            transition: opacity 0.2s ease;
            pointer-events: auto;
            cursor: pointer;
        }

        .scrubber-marker:hover {
            opacity: 1;
        }

        .scrubber-marker img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .marker-time {
            position: absolute;
            bottom: 2px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.625rem;
            font-family: 'IBM Plex Mono', monospace;
            color: var(--md-on-surface-variant);
            white-space: nowrap;
        }

        .scrubber-marker:first-child {
            left: 16px !important; /* Padding from edge */
            transform: none;
        }

        .scrubber-marker:first-child .marker-time {
            left: 0;
            transform: none;
        }

        .scrubber-marker:last-child {
            left: auto !important;
            right: 16px; /* Padding from edge */
            transform: none;
        }

        .scrubber-marker:last-child .marker-time {
            left: auto;
            right: 0;
            transform: none;
        }

        /* Position info overlay */
        .frame-picker-position-info {
            position: absolute;
            bottom: 12px;
            right: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 10px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(8px);
            border-radius: 6px;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.875rem;
            color: #fff;
        }

        .frame-picker-position-info > .material-symbols-outlined {
            font-size: 16px;
            color: var(--md-primary);
        }

        .position-label {
            font-size: 0.6875rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--md-on-surface-variant);
        }

        .position-value {
            font-size: 0.8125rem;
            font-family: 'IBM Plex Mono', monospace;
            color: var(--md-primary);
            font-weight: 500;
        }

        .position-clear-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            width: 20px;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 50%;
            color: var(--md-on-surface-variant);
            cursor: pointer;
            transition: all var(--md-duration-short3) var(--md-easing-standard);
        }

        .position-clear-btn .material-symbols-outlined {
            font-size: 14px;
        }

        .position-clear-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            color: var(--md-on-surface);
        }

        /* Footer */
        .frame-picker-footer {
            display: flex;
            justify-content: flex-end;
            gap: 12px;
            padding: 16px 24px;
            background: var(--md-surface-container-high);
            border-top: 1px solid var(--md-outline-variant);
        }

        .frame-picker-footer .btn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px 24px;
            border-radius: 20px;
            font-size: 0.875rem;
            font-weight: 500;
        }

        .frame-picker-footer .btn .material-symbols-outlined {
            font-size: 18px;
        }

        .frame-picker-footer .btn-primary {
            background: var(--md-primary);
            color: var(--md-on-primary);
            border: none;
        }

        .frame-picker-footer .btn-primary:hover {
            background: var(--primary-hover);
        }

        .frame-picker-footer .btn-secondary {
            background: transparent;
            border: 1px solid var(--md-outline);
            color: var(--md-on-surface);
        }

        .frame-picker-footer .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.08);
        }

        /* ═══════════════════════════════════════════════════════════
           MD3 Card - Step Cards with Staggered Animation
           ═══════════════════════════════════════════════════════════ */
        .step-card {
            background: var(--md-surface-container-low);
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 16px;
            border: none;
            transition:
                background-color var(--md-duration-short3) var(--md-easing-standard),
                box-shadow var(--md-duration-medium1) var(--md-easing-emphasized),
                transform var(--md-duration-short4) var(--md-easing-standard);
            animation: fadeInScale var(--md-duration-medium3) var(--md-easing-emphasized-decelerate) backwards;
            box-shadow:
                0 1px 2px rgba(0, 0, 0, 0.3),
                0 1px 3px 1px rgba(0, 0, 0, 0.15);
            position: relative;
            overflow: hidden;
        }

        /* Staggered animation delays for step cards */
        .step-card:nth-child(1) { animation-delay: 0ms; }
        .step-card:nth-child(2) { animation-delay: 50ms; }
        .step-card:nth-child(3) { animation-delay: 100ms; }
        .step-card:nth-child(4) { animation-delay: 150ms; }
        .step-card:nth-child(5) { animation-delay: 200ms; }
        .step-card:nth-child(6) { animation-delay: 250ms; }
        .step-card:nth-child(7) { animation-delay: 300ms; }
        .step-card:nth-child(8) { animation-delay: 350ms; }
        .step-card:nth-child(n+9) { animation-delay: 400ms; }

        .step-card::before {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: inherit;
            background-color: transparent;
            transition: background-color var(--md-duration-short3) var(--md-easing-standard);
            pointer-events: none;
        }

        .step-card:hover {
            background: var(--md-surface-container);
            box-shadow:
                0 2px 6px rgba(0, 0, 0, 0.3),
                0 6px 10px 4px rgba(0, 0, 0, 0.15);
            transform: translateY(-2px);
        }

        .step-card:hover::before {
            background-color: rgba(208, 188, 255, 0.04);
        }

        .step-card.active {
            background: var(--md-surface-container);
            box-shadow:
                0 0 0 2px var(--md-primary),
                0 2px 6px rgba(0, 0, 0, 0.3),
                0 6px 10px 4px rgba(0, 0, 0, 0.15);
        }

        .step-card.active::before {
            background-color: rgba(208, 188, 255, 0.08);
        }

        .step-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
        }

        .step-title {
            display: flex;
            align-items: center;
            gap: 10px;
            flex: 1;
            min-width: 0;
        }

        /* MD3 Badge - Step Number */
        .step-number {
            width: 32px;
            height: 32px;
            background: var(--md-primary);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--md-on-primary);
            flex-shrink: 0;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
            transition: transform var(--md-duration-short3) var(--md-easing-standard);
        }

        .step-card:hover .step-number {
            transform: scale(1.05);
        }

        .step-action {
            font-weight: 600;
            font-size: 1.1rem;
        }

        .step-action.tap { color: var(--action-tap); }
        .step-action.verify { color: var(--action-verify); }
        .step-action.wait { color: var(--action-wait); }
        .step-action.type { color: var(--action-type); }
        .step-action.swipe { color: var(--action-swipe); }

        .step-action-title {
            font-size: 0.95rem;
            font-weight: 500;
            color: var(--text-primary);
            flex: 1;
            min-width: 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            cursor: text;
            padding: 4px 8px;
            margin-right: 16px;
            border-radius: 4px;
            transition: background 0.2s, border-color 0.2s;
            border: 1px solid transparent;
        }

        .step-action-title:hover {
            background: var(--bg-tertiary);
            border-color: var(--border-color);
        }

        /* Horizontal split layout (top: info, bottom: frames) */
        .step-content {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .step-info {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .step-frames-row {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            padding: 16px;
            background: var(--bg-primary);
            border-radius: 8px;
        }

        .no-frames {
            padding: 40px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-secondary);
            font-size: 0.8rem;
        }

        .section-header {
            font-size: 0.7rem;
            text-transform: uppercase;
            color: var(--text-secondary);
            letter-spacing: 0.5px;
            margin-bottom: 8px;
            font-weight: 600;
        }

        /* MD3 Assist Chip / Badge */
        .gesture-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 0.75rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            background: var(--md-surface-container-high);
            margin-right: 8px;
            white-space: nowrap;
            transition: all var(--md-duration-short3) var(--md-easing-standard);
            border: 1px solid transparent;
        }

        .gesture-badge .material-symbols-outlined {
            font-size: 16px;
        }

        .gesture-badge.tap {
            background: var(--action-tap-bg);
            color: var(--action-tap);
            border-color: rgba(208, 188, 255, 0.3);
        }
        .gesture-badge.swipe {
            background: var(--action-swipe-bg);
            color: var(--action-swipe);
            border-color: rgba(239, 184, 200, 0.3);
        }
        .gesture-badge.verify, .gesture-badge.verifyscreen {
            background: var(--action-verify-bg);
            color: var(--action-verify);
            border-color: rgba(168, 213, 162, 0.3);
        }
        .gesture-badge.wait, .gesture-badge.waitfor {
            background: var(--action-wait-bg);
            color: var(--action-wait);
            border-color: rgba(255, 185, 87, 0.3);
        }
        .gesture-badge.type {
            background: var(--action-type-bg);
            color: var(--action-type);
            border-color: rgba(144, 202, 249, 0.3);
        }
        .gesture-badge.longpress, .gesture-badge.doubletap {
            background: var(--action-tap-bg);
            color: var(--action-tap);
            border-color: rgba(208, 188, 255, 0.3);
        }

        .step-controls {
            display: flex;
            gap: 4px;
        }

        /* MD3 Icon Button - Standard */
        .step-controls button {
            width: 40px;
            height: 40px;
            border: none;
            background: transparent;
            color: var(--md-on-surface-variant);
            border-radius: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all var(--transition-fast);
        }

        .step-controls button:hover {
            background: var(--accent-muted);
            color: var(--md-on-surface);
        }

        .step-controls button:active {
            background: rgba(208, 188, 255, 0.24);
        }

        .step-controls button.delete:hover {
            background: var(--fail-bg);
            color: var(--fail-color);
        }

        .step-controls button .material-symbols-outlined {
            font-size: 24px;
        }

        .step-controls button.add-verify {
            width: auto;
            padding: 0 10px;
            font-size: 0.7rem;
            font-weight: 500;
            background: rgba(139, 92, 246, 0.2);
            color: var(--action-verify);
            border: 1px solid var(--action-verify);
        }

        .step-controls button.add-verify:hover {
            background: var(--action-verify);
            color: white;
        }

        /* ═══════════════════════════════════════════════════════════
           Frame Display - 3 Column Story Layout with MD3 Styling
           ═══════════════════════════════════════════════════════════ */
        .step-frames {
            display: flex;
            gap: 16px;
            align-items: stretch; /* Equal height columns */
        }

        .frame-column {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--md-surface-container);
            border-radius: 16px;
            overflow: hidden;
            border: none;
            container-type: inline-size;
            transition: all var(--md-duration-short3) var(--md-easing-standard);
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }

        /* Push add buttons to bottom of column */
        .frame-column .column-spacer {
            flex: 1;
            min-height: 8px;
        }

        .frame-column.before {
            background: var(--md-surface-container);
            border: 1px solid var(--md-outline-variant);
        }
        .frame-column.action {
            background: var(--md-surface-container);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4), 0 0 0 2px var(--md-primary-container);
            z-index: 1;
        }
        .frame-column.after {
            background: var(--md-surface-container);
            border: 1px solid var(--md-outline-variant);
        }

        .frame-column-header {
            padding: 14px 16px;
            text-align: center;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            border-radius: 16px 16px 0 0;
            position: relative;
        }

        .frame-column.before .frame-column-header {
            background: var(--md-surface-container-high);
            color: var(--md-on-surface-variant);
            border-bottom: 1px solid var(--md-outline-variant);
        }
        .frame-column.action .frame-column-header {
            background: var(--md-primary-container);
            color: var(--md-on-primary-container);
            font-weight: 700;
            letter-spacing: 0.12em;
        }
        .frame-column.after .frame-column-header {
            background: rgba(168, 213, 162, 0.25);
            color: var(--pass-color);
            border-bottom: 1px solid rgba(168, 213, 162, 0.3);
        }

        .frame-image-container {
            position: relative;
            width: 100%;
            max-height: 500px;
            background: var(--bg-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            overflow: hidden;
        }

        .frame-image-container img {
            max-width: 100%;
            max-height: 500px;
            object-fit: contain;
        }

        .frame-image-container.clickable {
            cursor: pointer;
        }

        .frame-image-container.clickable:hover {
            background: rgba(208, 188, 255, 0.08);
        }

        .frame-edit-hint {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 32px;
            height: 32px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.15s ease;
            pointer-events: none;
        }

        .frame-edit-hint .material-symbols-outlined {
            font-size: 18px;
            color: #fff;
        }

        .frame-image-container.clickable:hover .frame-edit-hint {
            opacity: 1;
        }

        .gesture-indicator-wrapper {
            position: absolute;
            pointer-events: none;
            /* Initial size covers container, adjusted by positionIndicator on image load */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .frame-description {
            padding: 12px 14px;
            padding-top: 18px;
            font-size: 0.875rem;
            font-weight: 400;
            color: var(--md-on-surface);
            line-height: 1.5;
            min-height: 48px;
            cursor: text;
            transition: all var(--md-duration-short3) var(--md-easing-standard);
            letter-spacing: 0.01em;
            position: relative;
            border-radius: 8px;
            margin: 8px 10px;
            border: 1px solid var(--md-outline);
            background: transparent;
        }

        .frame-description::before {
            content: 'Description';
            position: absolute;
            top: -8px;
            left: 10px;
            padding: 0 4px;
            background: var(--md-surface-container);
            font-size: 0.6875rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--md-on-surface-variant);
        }

        .frame-description:hover {
            border-color: var(--md-on-surface);
            background: rgba(255, 255, 255, 0.02);
        }

        .frame-description:focus {
            border: 2px solid var(--md-primary);
            padding: 11px 13px;
            padding-top: 17px;
            outline: none;
        }

        .frame-description:empty::after {
            content: attr(data-placeholder);
            color: var(--md-on-surface-variant);
            opacity: 0.6;
            font-style: italic;
        }

        .frame-description em {
            color: var(--text-secondary);
            font-style: normal;
        }

        /* MD3 Outlined Button style for + Condition / + Verification */
        .btn-add-inline {
            width: calc(100% - 20px);
            margin: 8px 10px;
            padding: 12px 16px;
            background: transparent;
            border: 1px dashed var(--md-outline);
            border-radius: 8px;
            color: var(--md-on-surface-variant);
            font-size: 0.8125rem;
            font-weight: 500;
            letter-spacing: 0.02em;
            cursor: pointer;
            transition: all var(--md-duration-short3) var(--md-easing-standard);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            position: relative;
            overflow: hidden;
        }

        .btn-add-inline .material-symbols-outlined {
            font-size: 18px;
        }

        .btn-add-inline::before {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: inherit;
            background-color: transparent;
            transition: background-color var(--md-duration-short3) var(--md-easing-standard);
        }

        .btn-add-inline:hover {
            border-style: solid;
            border-color: var(--md-on-surface);
            color: var(--md-on-surface);
        }

        .btn-add-inline:hover::before {
            background-color: rgba(255, 255, 255, 0.04);
        }

        .btn-add-inline:active::before {
            background-color: rgba(255, 255, 255, 0.08);
        }

        /* Condition button - warning/amber color */
        .frame-column.before .btn-add-inline {
            border-color: rgba(255, 185, 87, 0.4);
            color: var(--warning-color);
        }

        .frame-column.before .btn-add-inline:hover {
            border-color: var(--warning-color);
        }

        .frame-column.before .btn-add-inline:hover::before {
            background-color: rgba(255, 185, 87, 0.08);
        }

        .frame-column.before .btn-add-inline:active::before {
            background-color: rgba(255, 185, 87, 0.12);
        }

        /* Verification button - success/green color */
        .frame-column.after .btn-add-inline {
            border-color: rgba(168, 213, 162, 0.4);
            color: var(--pass-color);
        }

        .frame-column.after .btn-add-inline:hover {
            border-color: var(--pass-color);
        }

        .frame-column.after .btn-add-inline:hover::before {
            background-color: rgba(168, 213, 162, 0.08);
        }

        .frame-column.after .btn-add-inline:active::before {
            background-color: rgba(168, 213, 162, 0.12);
        }

        /* Inline add form (shown when clicking + Condition or + Verification) */
        .inline-add-form {
            border-top: 1px solid var(--border-color);
            padding: 10px;
            background: var(--bg-tertiary);
            margin-top: auto;
        }

        .inline-add-form label {
            display: block;
            font-size: 0.7rem;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }

        .inline-add-form select,
        .inline-add-form input[type="text"] {
            width: 100%;
            padding: 6px 8px;
            font-size: 0.8rem;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
            margin-bottom: 8px;
        }

        .inline-add-form-buttons {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
        }

        .inline-add-form-buttons button {
            padding: 5px 12px;
            font-size: 0.75rem;
            border-radius: 4px;
            cursor: pointer;
            border: none;
        }

        .inline-add-form-buttons .btn-cancel {
            background: var(--bg-secondary);
            color: var(--text-secondary);
        }

        .inline-add-form-buttons .btn-add {
            background: var(--accent-color);
            color: white;
        }

        .frame-column.before .inline-add-form-buttons .btn-add {
            background: var(--warning-color);
        }

        .frame-column.after .inline-add-form-buttons .btn-add {
            background: var(--pass-color);
        }

        /* Conditions list (multiple conditions) */
        .conditions-list {
            border-top: 1px solid var(--border-color);
        }

        .condition-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 10px;
            font-size: 0.75rem;
            border-bottom: 1px solid var(--border-color);
            background: rgba(245, 158, 11, 0.05);
        }

        .condition-item:last-child {
            border-bottom: none;
        }

        .condition-item:hover {
            background: rgba(245, 158, 11, 0.1);
        }

        .condition-item-text {
            color: var(--warning-color);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .condition-item-type {
            font-weight: 500;
        }

        .condition-item-value {
            color: var(--text-primary);
            font-style: italic;
        }

        .condition-item-remove {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 2px 6px;
            font-size: 1rem;
            line-height: 1;
            opacity: 0.5;
        }

        .condition-item-remove:hover {
            opacity: 1;
            color: var(--fail-color);
        }

        /* Verifications list - styled like text fields */
        .verifications-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 0 10px;
            margin-top: 8px;
        }

        .verification-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 12px;
            padding-top: 16px;
            font-size: 0.875rem;
            border: 1px solid rgba(168, 213, 162, 0.5);
            border-radius: 8px;
            background: transparent;
            position: relative;
        }

        .verification-item::before {
            content: 'Verify';
            position: absolute;
            top: -8px;
            left: 10px;
            padding: 0 4px;
            background: var(--md-surface-container);
            font-size: 0.6875rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--pass-color);
        }

        .verification-item:hover {
            border-color: var(--pass-color);
        }

        .verification-item-text {
            color: var(--md-on-surface);
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 1;
            min-width: 0;
        }

        .verification-item-text .material-symbols-outlined {
            color: var(--pass-color);
            font-size: 18px;
        }

        .verification-item-value {
            color: var(--md-on-surface);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .verification-item-remove {
            background: none;
            border: none;
            color: var(--md-on-surface-variant);
            cursor: pointer;
            padding: 4px;
            font-size: 1rem;
            line-height: 1;
            opacity: 0.6;
            border-radius: 4px;
            transition: all var(--md-duration-short2) var(--md-easing-standard);
            flex-shrink: 0;
        }

        .verification-item-remove:hover {
            opacity: 1;
            color: var(--fail-color);
            background: rgba(239, 68, 68, 0.1);
        }

        .verification-item-remove .material-symbols-outlined {
            font-size: 18px;
        }

        /* Inline Suggested Verification in AFTER column */
        .suggested-verification-inline {
            margin: 8px 10px;
            padding: 10px 12px;
            padding-top: 16px;
            background: transparent;
            border: 1px dashed rgba(250, 204, 21, 0.5);
            border-radius: 8px;
            position: relative;
        }

        .suggested-verification-inline::before {
            content: 'Suggested';
            position: absolute;
            top: -8px;
            left: 10px;
            padding: 0 4px;
            background: var(--md-surface-container);
            font-size: 0.6875rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--warning-color);
        }

        .suggestion-inline-header {
            display: none; /* Hidden - using ::before floating label instead */
        }

        .suggestion-inline-text {
            font-size: 0.875rem;
            color: var(--md-on-surface);
            line-height: 1.4;
            margin-bottom: 10px;
        }

        .suggestion-inline-actions {
            display: flex;
            gap: 4px;
        }

        .suggestion-inline-actions button {
            width: 28px;
            height: 28px;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
        }

        .suggestion-inline-actions button .material-symbols-outlined {
            font-size: 16px;
        }

        .btn-suggestion-add {
            background: var(--pass-color);
            color: #000;
        }
        .btn-suggestion-add:hover {
            background: #86efac;
            transform: scale(1.1);
        }

        .btn-suggestion-edit {
            background: var(--md-surface-container-high);
            color: var(--text-primary);
        }
        .btn-suggestion-edit:hover {
            background: var(--md-surface-container-highest);
        }

        .btn-suggestion-skip {
            background: var(--md-surface-container-high);
            color: var(--text-secondary);
        }
        .btn-suggestion-skip:hover {
            background: rgba(239, 68, 68, 0.2);
            color: var(--fail-color);
        }

        /* MD3 Gesture Info Panel - Modern Redesign */
        .frame-gesture-info {
            padding: 14px 16px;
            border-top: 1px solid var(--md-outline-variant);
            background: linear-gradient(to bottom,
                var(--md-surface-container-low) 0%,
                var(--md-surface-container-lowest) 100%);
            font-size: 0.8125rem;
            display: flex;
            flex-wrap: wrap;
            gap: 12px 16px;
            align-items: center;
        }

        .frame-gesture-info .gesture-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .frame-gesture-info .gesture-label {
            color: var(--md-on-surface-variant);
            font-size: 0.6875rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.04em;
        }

        .frame-gesture-info .gesture-info-secondary {
            color: var(--md-on-surface-variant);
            font-size: 0.625rem;
            font-weight: 400;
            text-transform: none;
            letter-spacing: normal;
            opacity: 0.8;
        }

        .frame-gesture-info .gesture-value {
            color: var(--md-primary);
            font-weight: 500;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.8125rem;
        }

        /* MD3 Outlined Text Field style inputs */
        .frame-gesture-info select,
        .frame-gesture-info input {
            background: transparent;
            border: 1px solid var(--md-outline);
            border-radius: 8px;
            padding: 10px 12px;
            color: var(--md-on-surface);
            font-size: 0.8125rem;
            font-family: 'IBM Plex Mono', monospace;
            transition: all var(--md-duration-short3) var(--md-easing-standard);
        }

        .frame-gesture-info select {
            padding-right: 32px;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%239ca3af' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpolyline points='6 9 12 15 18 9'%3E%3C/polyline%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 10px center;
        }

        .frame-gesture-info select:hover,
        .frame-gesture-info input:hover {
            border-color: var(--md-on-surface);
            background: rgba(255, 255, 255, 0.03);
        }

        .frame-gesture-info select:focus,
        .frame-gesture-info input:focus {
            outline: none;
            border: 2px solid var(--md-primary);
            padding: 9px 11px;
            background: rgba(var(--md-primary-rgb), 0.05);
        }

        .frame-gesture-info input[type="number"] {
            width: 70px;
            min-width: 70px;
            text-align: center;
        }

        .frame-gesture-info input[type="text"] {
            width: 100%;
        }

        /* Modern Grid layout for gesture controls */
        .frame-gesture-info.gesture-grid {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 12px;
            padding: 16px;
            padding-top: 24px;
            background: var(--md-surface-container);
            margin-top: auto; /* Push to bottom of column */
            position: relative;
        }

        /* Horizontal divider above gesture controls */
        .frame-gesture-info.gesture-grid::before {
            content: '';
            position: absolute;
            top: 0;
            left: 16px;
            right: 16px;
            height: 1px;
            background: linear-gradient(
                90deg,
                transparent 0%,
                var(--md-outline-variant) 15%,
                var(--md-outline-variant) 85%,
                transparent 100%
            );
        }

        /* Stack vertically on narrow containers */
        @container (max-width: 280px) {
            .frame-gesture-info.gesture-grid {
                grid-template-columns: 1fr;
            }
            .frame-gesture-info .gesture-cell.full-width {
                grid-column: span 1;
            }
        }

        .frame-gesture-info .gesture-cell {
            display: flex;
            flex-direction: column;
            gap: 4px;
            min-width: 0;
            overflow: visible;
            position: relative;
        }

        .frame-gesture-info .gesture-cell.full-width {
            grid-column: span 2;
        }

        .frame-gesture-info .gesture-cell .gesture-label {
            position: absolute;
            top: -8px;
            left: 10px;
            padding: 0 4px;
            background: var(--md-surface-container);
            font-size: 0.6875rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--md-on-surface-variant);
            z-index: 1;
        }

        .frame-gesture-info .gesture-cell select,
        .frame-gesture-info .gesture-cell input {
            width: 100%;
            min-width: 0;
        }

        .frame-gesture-info .gesture-cell input[type="number"] {
            width: 100%;
            min-width: 0;
            padding-right: 28px;
        }

        .frame-gesture-info .gesture-unit {
            position: absolute;
            right: 10px;
            bottom: 10px;
            color: var(--md-on-surface-variant);
            font-size: 0.75rem;
            font-weight: 500;
            pointer-events: none;
        }

        /* Custom number input spinners for dark theme */
        input[type="number"] {
            -moz-appearance: textfield;
            appearance: textfield;
        }

        input[type="number"]::-webkit-outer-spin-button,
        input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        /* Custom spinner wrapper for number inputs */
        .number-input-wrapper {
            position: relative;
            display: inline-flex;
            align-items: center;
        }

        .number-input-wrapper input[type="number"] {
            padding-right: 28px;
        }

        .number-spinner {
            position: absolute;
            right: 4px;
            display: flex;
            flex-direction: column;
            gap: 1px;
        }

        .number-spinner button {
            width: 20px;
            height: 14px;
            padding: 0;
            border: none;
            background: transparent;
            color: var(--md-on-surface-variant);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 2px;
            transition: all var(--md-duration-short2) var(--md-easing-standard);
        }

        .number-spinner button:hover {
            background: var(--md-surface-container-highest);
            color: var(--md-on-surface);
        }

        .number-spinner button:active {
            background: var(--md-primary-container);
            color: var(--md-on-primary-container);
        }

        .number-spinner button .material-symbols-rounded {
            font-size: 14px;
        }

        /* Legacy support */
        .frame-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }

        .frame-wrapper {
            position: relative;
            width: 100px;
            height: 180px;
        }

        .frame-wrapper img {
            position: absolute;
            top: 0;
            left: 0;
            opacity: 0;
            transition: opacity 0.15s ease-in-out;
        }

        .frame-wrapper img.active {
            opacity: 1;
        }

        .frame-arrow {
            color: var(--text-secondary);
            font-size: 1.5rem;
            font-weight: bold;
        }

        /* ═══════════════════════════════════════════════════════════
           Enhanced Gesture Indicators - Material Touch Feedback
           ═══════════════════════════════════════════════════════════ */

        /* Tap indicator - High contrast with dark outline */
        .tap-indicator {
            position: absolute;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: var(--md-primary);
            border: 3px solid #fff;
            box-shadow:
                0 0 0 2px rgba(0, 0, 0, 0.8),
                0 4px 12px rgba(0, 0, 0, 0.5),
                0 0 20px rgba(208, 188, 255, 0.6);
            transform: translate(-50%, -50%);
            pointer-events: none;
            animation: tapBounce 1.5s cubic-bezier(0.34, 1.56, 0.64, 1) infinite;
        }

        /* Inner dot */
        .tap-indicator::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 14px;
            height: 14px;
            background: #fff;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
        }

        /* Ripple ring */
        .tap-indicator::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 60px;
            height: 60px;
            border: 3px solid #fff;
            box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            animation: tapRipple1 1.5s ease-out infinite;
        }

        @keyframes tapBounce {
            0%, 100% {
                transform: translate(-50%, -50%) scale(1);
                filter: drop-shadow(0 0 12px rgba(208, 188, 255, 1));
            }
            50% {
                transform: translate(-50%, -50%) scale(0.85);
                filter: drop-shadow(0 0 20px rgba(208, 188, 255, 1));
            }
        }

        @keyframes tapRipple1 {
            0% {
                transform: translate(-50%, -50%) scale(0.6);
                opacity: 1;
            }
            100% {
                transform: translate(-50%, -50%) scale(1.6);
                opacity: 0;
            }
        }

        /* Long press indicator - High contrast progress ring */
        .long-press-indicator {
            position: absolute;
            width: 52px;
            height: 52px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.4);
            border: 3px solid #fff;
            box-shadow:
                0 0 0 2px rgba(0, 0, 0, 0.8),
                0 4px 16px rgba(0, 0, 0, 0.5),
                0 0 20px rgba(208, 188, 255, 0.5);
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        /* Inner dot */
        .long-press-indicator::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 18px;
            height: 18px;
            background: var(--md-primary);
            border: 2px solid #fff;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            animation: longPressPulse 1s ease-in-out infinite;
        }

        /* Animated progress arc */
        .long-press-indicator::after {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            width: calc(100% + 6px);
            height: calc(100% + 6px);
            border-radius: 50%;
            border: 4px solid transparent;
            border-top-color: var(--md-primary);
            border-right-color: var(--md-primary);
            box-sizing: border-box;
            animation: longPressProgress 1.5s linear infinite;
            filter: drop-shadow(0 0 6px rgba(208, 188, 255, 0.8));
        }

        @keyframes longPressPulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(0.8); }
        }

        @keyframes longPressProgress {
            0% {
                transform: rotate(0deg);
            }
            100% {
                transform: rotate(360deg);
            }
        }

        /* Double tap indicator */
        .double-tap-indicator {
            position: absolute;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        .double-tap-indicator .tap-circle {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid #fff;
            background: rgba(245, 158, 11, 0.7);
            box-shadow: 0 0 0 2px var(--action-tap), 0 2px 8px rgba(0,0,0,0.3);
        }

        .double-tap-indicator .tap-1 {
            top: -14px;
            left: -14px;
            animation: doubleTap1 1s ease-in-out infinite;
        }

        .double-tap-indicator .tap-2 {
            top: -6px;
            left: -6px;
            animation: doubleTap2 1s ease-in-out infinite;
        }

        @keyframes doubleTap1 {
            0%, 100% { transform: scale(1); opacity: 1; }
            25% { transform: scale(0.7); opacity: 0.4; }
            50% { transform: scale(1); opacity: 1; }
            75% { transform: scale(1); opacity: 1; }
        }

        @keyframes doubleTap2 {
            0%, 100% { transform: scale(0.8); opacity: 0.6; }
            25% { transform: scale(0.8); opacity: 0.6; }
            50% { transform: scale(0.7); opacity: 0.4; }
            75% { transform: scale(1); opacity: 1; }
        }

        /* Swipe indicator - Modern gradient trail */
        .swipe-indicator {
            position: absolute;
            pointer-events: none;
            z-index: 10;
        }

        /* Trajectory line - smooth gradient with glow */
        .swipe-indicator .swipe-trajectory-line {
            position: absolute;
            left: var(--start-x);
            top: var(--start-y);
            width: var(--line-length);
            height: 3px;
            background: linear-gradient(
                90deg,
                rgba(208, 188, 255, 0.1) 0%,
                rgba(208, 188, 255, 0.4) 20%,
                rgba(208, 188, 255, 0.8) 80%,
                var(--md-primary) 100%
            );
            transform-origin: 0 50%;
            transform: rotate(var(--line-angle)) translateY(-50%);
            border-radius: 2px;
            filter: drop-shadow(0 0 6px rgba(208, 188, 255, 0.5));
            animation: swipeTrailPulse 1.8s ease-in-out infinite;
        }

        /* Arrow at end of swipe */
        .swipe-indicator .swipe-trajectory-line::after {
            content: '';
            position: absolute;
            right: -6px;
            top: 50%;
            transform: translateY(-50%);
            width: 0;
            height: 0;
            border-left: 10px solid var(--md-primary);
            border-top: 6px solid transparent;
            border-bottom: 6px solid transparent;
            filter: drop-shadow(0 0 4px rgba(208, 188, 255, 0.8));
        }

        /* Animated dot with comet trail */
        .swipe-indicator .swipe-dot {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: radial-gradient(circle, #fff 30%, var(--md-primary) 100%);
            transform: translate(-50%, -50%);
            left: var(--start-x);
            top: var(--start-y);
            animation: swipeMove 1.8s cubic-bezier(0.4, 0, 0.2, 1) infinite;
            filter: drop-shadow(0 0 10px rgba(208, 188, 255, 0.9));
        }

        /* Comet trail effect */
        .swipe-indicator .swipe-dot::before {
            content: '';
            position: absolute;
            top: 50%;
            right: 100%;
            width: 30px;
            height: 4px;
            background: linear-gradient(90deg, transparent, rgba(208, 188, 255, 0.8));
            transform: translateY(-50%);
            border-radius: 2px;
            opacity: 0;
            animation: swipeTrail 1.8s cubic-bezier(0.4, 0, 0.2, 1) infinite;
        }

        .swipe-indicator .swipe-dot::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 8px;
            height: 8px;
            background: #fff;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        @keyframes swipeTrailPulse {
            0%, 70%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        @keyframes swipeMove {
            0% {
                left: var(--start-x);
                top: var(--start-y);
                transform: translate(-50%, -50%) scale(1);
            }
            5% {
                transform: translate(-50%, -50%) scale(0.8);
            }
            45% {
                left: var(--end-x);
                top: var(--end-y);
                transform: translate(-50%, -50%) scale(1.1);
            }
            50% {
                left: var(--end-x);
                top: var(--end-y);
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
            55% {
                opacity: 0;
            }
            56% {
                left: var(--start-x);
                top: var(--start-y);
                opacity: 0;
            }
            70%, 100% {
                left: var(--start-x);
                top: var(--start-y);
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        @keyframes swipeTrail {
            0%, 56%, 100% { opacity: 0; width: 20px; }
            10% { opacity: 0.8; }
            45% { opacity: 0.8; width: 40px; }
            55% { opacity: 0; }
        }

        .frame-label {
            font-size: 0.7rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
        }

        .frame-label.before { color: var(--action-wait); }
        .frame-label.action { color: var(--action-tap); }
        .frame-label.after { color: var(--pass-color); }

        /* Step summary - single line description */
        .step-summary {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 16px;
            background: var(--bg-tertiary);
            border-radius: 6px;
            font-size: 0.8rem;
            margin-top: 12px;
        }

        .step-summary .summary-label {
            color: var(--text-secondary);
            font-weight: 500;
            white-space: nowrap;
        }

        .step-summary .summary-label.before { color: var(--action-wait); }
        .step-summary .summary-label.action { color: var(--action-tap); }
        .step-summary .summary-label.after { color: var(--pass-color); }

        .step-summary .summary-text {
            color: var(--text-primary);
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            cursor: pointer;
        }

        .step-summary .summary-text:hover {
            color: var(--accent-color);
        }

        .step-summary .summary-arrow {
            color: var(--text-secondary);
            opacity: 0.5;
        }

        .frame-img {
            width: 100px;
            height: 180px;
            object-fit: cover;
            border-radius: 10px;
            border: 2px solid var(--border-color);
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .frame-img:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }

        .frame-container.before .frame-img { border-color: var(--action-wait); }
        .frame-container.action .frame-img { border-color: var(--action-tap); }
        .frame-container.after .frame-img { border-color: var(--pass-color); }

        /* Analysis Section */
        .step-analysis {
            background: var(--bg-tertiary);
            border-radius: 6px;
            padding: 12px;
            font-size: 0.875rem;
        }

        .analysis-row {
            display: flex;
            margin-bottom: 6px;
        }

        .analysis-row:last-child {
            margin-bottom: 0;
        }

        .analysis-label {
            width: 60px;
            color: var(--text-secondary);
            flex-shrink: 0;
        }

        .analysis-value {
            color: var(--text-primary);
        }

        .analysis-value.editable {
            cursor: pointer;
            padding: 2px 6px;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .analysis-value.editable:hover {
            background: var(--bg-secondary);
        }

        .step-section {
            margin-bottom: 12px;
        }

        .step-coordinates {
            display: flex;
            gap: 16px;
            padding: 10px 12px;
            background: var(--bg-tertiary);
            border-radius: 6px;
            font-size: 0.8rem;
        }

        .coord-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .coord-label {
            color: var(--text-secondary);
        }

        .coord-value {
            font-weight: 600;
            color: var(--accent-color);
            font-family: 'SF Mono', Monaco, monospace;
            min-width: 40px;
        }

        .coord-px {
            color: var(--text-secondary);
            font-size: 0.75rem;
            opacity: 0.7;
        }

        /* Swipe info styling */
        .swipe-info .swipe-direction {
            color: var(--action-swipe);
        }

        /* Type info styling */
        .type-info .type-text {
            color: var(--action-type);
            font-family: 'SF Mono', Monaco, monospace;
        }

        .type-info .submit-yes {
            color: var(--pass-color);
        }

        .type-info .submit-no {
            color: var(--text-secondary);
        }

        /* Suggested Verification */
        .step-suggestion {
            background: rgba(139, 92, 246, 0.1);
            border: 1px solid rgba(139, 92, 246, 0.3);
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 12px;
        }

        .suggestion-header {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 8px;
            color: var(--action-verify);
            font-size: 0.75rem;
            font-weight: 500;
        }

        .suggestion-text {
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 0.8rem;
            margin-bottom: 8px;
        }

        .suggestion-actions {
            display: flex;
            gap: 8px;
        }

        .suggestion-actions button {
            padding: 4px 12px;
            font-size: 0.75rem;
        }

        /* Conditional Section - Collapsed by default */
        .step-conditional {
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 6px;
            margin-bottom: 12px;
            overflow: hidden;
        }

        .step-conditional.collapsed {
            background: transparent;
            border: 1px dashed rgba(59, 130, 246, 0.15);
            padding: 4px 10px;
            opacity: 0.6;
        }

        .step-conditional.collapsed:hover {
            opacity: 1;
        }

        .step-conditional:not(.collapsed) {
            padding: 12px;
        }

        .conditional-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }

        .step-conditional:not(.collapsed) .conditional-header {
            margin-bottom: 8px;
        }

        .conditional-expand-hint {
            font-size: 0.7rem;
            color: var(--text-secondary);
            opacity: 0.6;
        }

        .step-conditional:not(.collapsed) .conditional-expand-hint {
            display: none;
        }

        .conditional-label {
            font-size: 0.75rem;
            font-weight: 500;
            color: var(--accent-color);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .conditional-toggle {
            width: 20px;
            height: 20px;
            cursor: pointer;
            accent-color: var(--accent-color);
        }

        .conditional-config {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }

        .conditional-field {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .conditional-field label {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .conditional-field select,
        .conditional-field input {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 4px 8px;
            color: var(--text-primary);
            font-size: 0.8rem;
        }

        .conditional-field select {
            min-width: 140px;
        }

        .conditional-field input {
            min-width: 180px;
        }

        .conditional-field .cond-screen-input {
            min-width: 280px;
        }

        .conditional-badge {
            background: var(--accent-color);
            color: white;
            font-size: 0.65rem;
            padding: 2px 6px;
            border-radius: 3px;
            margin-left: 8px;
        }

        /* Gesture Config - combines info display with editor */
        .gesture-config {
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
            align-items: center;
            padding: 12px;
            background: var(--bg-tertiary);
            border-radius: 6px;
        }

        .gesture-config .config-group {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .gesture-config .config-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .gesture-config .config-value {
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--accent-color);
            font-family: 'SF Mono', Monaco, monospace;
        }

        .gesture-config .config-value.highlight {
            color: var(--action-swipe);
        }

        .gesture-config input,
        .gesture-config select {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 4px 8px;
            color: var(--text-primary);
            font-size: 0.8rem;
        }

        .gesture-config input[type="number"] {
            width: 70px;
        }

        .gesture-config input[type="text"] {
            width: 150px;
        }

        .gesture-config select {
            min-width: 80px;
        }

        /* Step Editor */
        .step-editor {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
        }

        .editor-field {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .editor-field label {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .editor-field input,
        .editor-field select {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 6px 10px;
            color: var(--text-primary);
            font-size: 0.875rem;
        }

        .editor-field input:focus,
        .editor-field select:focus {
            outline: none;
            border-color: var(--accent-color);
        }

        .editor-field input[type="number"] {
            width: 80px;
        }

        /* Add Step Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-overlay.active {
            display: flex;
        }

        .modal {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 24px;
            width: 400px;
            max-width: 90%;
        }

        .modal h2 {
            font-size: 1.125rem;
            margin-bottom: 16px;
        }

        .modal-field {
            margin-bottom: 16px;
        }

        .modal-field label {
            display: block;
            font-size: 0.875rem;
            color: var(--text-secondary);
            margin-bottom: 6px;
        }

        .modal-field input,
        .modal-field textarea {
            width: 100%;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 10px;
            color: var(--text-primary);
            font-size: 0.875rem;
        }

        .modal-field textarea {
            height: 80px;
            resize: vertical;
        }

        .modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
        }

        /* ============================================================
           CONDITION COMPONENT STYLES (Step Model Redesign)
           ============================================================ */

        .step-condition {
            border-radius: 0;
            margin: 0;
            overflow: hidden;
            transition: all 0.2s ease-out;
            border-top: 1px solid var(--border-color);
        }

        .step-condition.collapsed {
            background: transparent;
        }

        .step-condition.collapsed:hover {
            background: rgba(245, 158, 11, 0.05);
        }

        .step-condition:not(.collapsed) {
            background: rgba(245, 158, 11, 0.1);
        }

        .condition-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            cursor: pointer;
            user-select: none;
        }

        .condition-header:hover {
            background: rgba(59, 130, 246, 0.05);
        }

        .condition-label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.75rem;
            font-weight: 500;
            color: var(--warning-color);
        }

        .condition-expand-hint {
            font-size: 0.7rem;
            color: var(--text-secondary);
            font-weight: 400;
            opacity: 0.6;
        }

        .step-condition:not(.collapsed) .condition-expand-hint {
            display: none;
        }

        .condition-remove-btn {
            width: 24px;
            height: 24px;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
            opacity: 0;
        }

        .step-condition:hover .condition-remove-btn,
        .step-condition:not(.collapsed) .condition-remove-btn {
            opacity: 1;
        }

        .condition-remove-btn:hover {
            background: var(--fail-color);
            color: white;
        }

        .condition-body {
            padding: 0 12px 12px 12px;
            display: none;
        }

        .step-condition:not(.collapsed) .condition-body {
            display: block;
        }

        .condition-field {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
        }

        .condition-field:last-child {
            margin-bottom: 0;
        }

        .condition-field label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            min-width: 50px;
        }

        .condition-field select,
        .condition-field input[type="text"] {
            flex: 1;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 6px 10px;
            color: var(--text-primary);
            font-size: 0.85rem;
        }

        .condition-field select:focus,
        .condition-field input:focus {
            outline: none;
            border-color: var(--accent-color);
        }

        .condition-elements-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .condition-element-row {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .condition-element-row input {
            flex: 1;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 6px 10px;
            color: var(--text-primary);
            font-size: 0.85rem;
        }

        .condition-element-remove {
            width: 24px;
            height: 24px;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
        }

        .condition-element-remove:hover {
            background: var(--fail-color);
            color: white;
        }

        .condition-add-element {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 10px;
            margin-top: 4px;
            background: transparent;
            border: 1px dashed var(--border-color);
            border-radius: 4px;
            color: var(--text-secondary);
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.15s;
        }

        .condition-add-element:hover {
            border-color: var(--accent-color);
            color: var(--accent-color);
        }

        .condition-preview {
            font-size: 0.7rem;
            color: var(--text-secondary);
            margin-left: 8px;
            max-width: 200px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .step-condition:not(.collapsed) .condition-preview {
            display: none;
        }

        /* ============================================================
           VERIFICATION COMPONENT STYLES (Step Model Redesign)
           ============================================================ */

        .step-verification {
            border-radius: 0;
            margin: 0;
            overflow: hidden;
            transition: all 0.2s ease-out;
            border-top: 1px solid var(--border-color);
        }

        .step-verification.collapsed {
            background: transparent;
        }

        .step-verification.collapsed:hover {
            background: rgba(16, 185, 129, 0.05);
        }

        .step-verification:not(.collapsed) {
            background: rgba(16, 185, 129, 0.1);
        }

        .verification-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            cursor: pointer;
            user-select: none;
        }

        .verification-header:hover {
            background: rgba(16, 185, 129, 0.05);
        }

        .verification-label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.75rem;
            font-weight: 500;
            color: var(--pass-color);
        }

        .verification-expand-hint {
            font-size: 0.7rem;
            color: var(--text-secondary);
            font-weight: 400;
            opacity: 0.6;
        }

        .step-verification:not(.collapsed) .verification-expand-hint {
            display: none;
        }

        .verification-remove-btn {
            width: 24px;
            height: 24px;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
            opacity: 0;
        }

        .step-verification:hover .verification-remove-btn,
        .step-verification:not(.collapsed) .verification-remove-btn {
            opacity: 1;
        }

        .verification-remove-btn:hover {
            background: var(--fail-color);
            color: white;
        }

        .verification-body {
            padding: 0 12px 12px 12px;
            display: none;
        }

        .step-verification:not(.collapsed) .verification-body {
            display: block;
        }

        .verification-hint {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-bottom: 8px;
        }

        .verification-textarea {
            width: 100%;
            min-height: 60px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 8px 10px;
            color: var(--text-primary);
            font-size: 0.85rem;
            font-family: inherit;
            resize: vertical;
        }

        .verification-textarea:focus {
            outline: none;
            border-color: var(--action-verify);
        }

        .verification-preview {
            font-size: 0.7rem;
            color: var(--text-secondary);
            margin-left: 8px;
            max-width: 200px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .step-verification:not(.collapsed) .verification-preview {
            display: none;
        }

        /* Add buttons for condition/verification */
        .btn-add-condition,
        .btn-add-verification {
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s;
            border: 1px dashed;
        }

        .btn-add-condition {
            background: transparent;
            border-color: rgba(59, 130, 246, 0.3);
            color: var(--accent-color);
        }

        .btn-add-condition:hover {
            background: rgba(59, 130, 246, 0.1);
            border-color: var(--accent-color);
        }

        .btn-add-verification {
            background: transparent;
            border-color: rgba(139, 92, 246, 0.3);
            color: var(--action-verify);
        }

        .btn-add-verification:hover {
            background: rgba(139, 92, 246, 0.1);
            border-color: var(--action-verify);
        }

        /* ============================================================
           VIDEO PICKER MODAL STYLES (Step Model Redesign)
           ============================================================ */

        .video-picker-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 3000;
            display: none;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(4px);
        }

        .video-picker-backdrop.active {
            display: flex;
        }

        .video-picker-modal {
            background: var(--bg-secondary);
            border-radius: 16px;
            border: 1px solid var(--border-color);
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            max-width: 800px;
            width: 90%;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .video-picker-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
        }

        .video-picker-title {
            font-size: 1.1rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .frame-type-badge {
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .frame-type-badge.before {
            background: rgba(107, 114, 128, 0.2);
            color: var(--action-wait);
        }

        .frame-type-badge.action {
            background: rgba(245, 158, 11, 0.2);
            color: var(--action-tap);
        }

        .frame-type-badge.after {
            background: rgba(16, 185, 129, 0.2);
            color: var(--pass-color);
        }

        .video-picker-close {
            width: 36px;
            height: 36px;
            border: none;
            background: var(--bg-secondary);
            color: var(--text-secondary);
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.2rem;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .video-picker-close:hover {
            background: var(--border-color);
            color: var(--text-primary);
        }

        .video-picker-body {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .video-picker-video-container {
            position: relative;
            background: #000;
            border-radius: 12px;
            overflow: hidden;
            max-height: 60vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .video-picker-video {
            max-width: 100%;
            max-height: 60vh;
            display: block;
        }

        .video-picker-overlay {
            position: absolute;
            cursor: crosshair;
            display: none;
        }

        .video-picker-overlay.active {
            display: block;
        }

        .video-picker-tap-indicator {
            position: absolute;
            width: 32px;
            height: 32px;
            border: 3px solid var(--action-tap);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            box-shadow: 0 0 15px rgba(245, 158, 11, 0.6);
            animation: vpTapPulse 1.5s ease-in-out infinite;
            display: none;
        }

        .video-picker-tap-indicator.visible {
            display: block;
        }

        .video-picker-tap-indicator::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 8px;
            height: 8px;
            background: var(--action-tap);
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        @keyframes vpTapPulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 0.7; }
        }

        .video-picker-instruction {
            text-align: center;
            color: var(--text-secondary);
            font-size: 0.9rem;
            padding: 8px;
            background: var(--bg-tertiary);
            border-radius: 8px;
        }

        .video-picker-instruction.highlight {
            color: var(--accent-color);
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid rgba(59, 130, 246, 0.3);
        }

        .video-picker-controls {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            background: var(--bg-tertiary);
            border-radius: 8px;
        }

        .video-picker-play-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: var(--accent-color);
            border: none;
            color: white;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            transition: background 0.15s;
        }

        .video-picker-play-btn:hover {
            background: #2563eb;
        }

        .video-picker-scrubber {
            flex: 1;
            height: 8px;
            -webkit-appearance: none;
            appearance: none;
            background: var(--bg-primary);
            border-radius: 4px;
            cursor: pointer;
        }

        .video-picker-scrubber::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--accent-color);
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .video-picker-time {
            font-size: 0.85rem;
            color: var(--text-secondary);
            font-family: 'SF Mono', Monaco, 'Courier New', monospace;
            white-space: nowrap;
            min-width: 100px;
            text-align: right;
        }

        .video-picker-description-section {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .video-picker-description-label {
            font-size: 0.8rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 600;
        }

        .video-picker-description-input {
            width: 100%;
            padding: 12px 14px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 0.95rem;
            transition: border-color 0.15s;
        }

        .video-picker-description-input:focus {
            outline: none;
            border-color: var(--accent-color);
        }

        .video-picker-position-info {
            display: none;
            padding: 12px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            border: 1px solid var(--border-color);
        }

        .video-picker-position-info.active {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .video-picker-position-coords {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .video-picker-coord {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .video-picker-coord-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            text-transform: uppercase;
        }

        .video-picker-coord-value {
            font-family: 'SF Mono', Monaco, 'Courier New', monospace;
            font-size: 0.9rem;
            color: var(--accent-color);
            font-weight: 600;
        }

        .video-picker-clear-position {
            padding: 6px 12px;
            background: transparent;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-secondary);
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.15s;
        }

        .video-picker-clear-position:hover {
            background: var(--bg-primary);
            border-color: var(--fail-color);
            color: var(--fail-color);
        }

        .video-picker-footer {
            display: flex;
            justify-content: flex-end;
            gap: 12px;
            padding: 16px 20px;
            background: var(--bg-tertiary);
            border-top: 1px solid var(--border-color);
        }

        .video-picker-btn {
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s;
            border: none;
        }

        .video-picker-btn-cancel {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        .video-picker-btn-cancel:hover {
            background: var(--border-color);
        }

        .video-picker-btn-capture {
            background: var(--accent-color);
            color: white;
        }

        .video-picker-btn-capture:hover {
            background: #2563eb;
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="header-left">
            <div class="header-meta">
                <span class="header-meta-item" id="headerStepCount">
                    <span class="material-symbols-outlined">touch_app</span>
                    <span id="stepCountValue">0</span> steps
                </span>
                <span class="header-meta-divider">•</span>
                <span class="header-meta-item" id="headerDuration">
                    <span class="material-symbols-outlined">schedule</span>
                    <span id="durationValue">0:00</span>
                </span>
                <span class="header-meta-divider">•</span>
                <span class="header-meta-item" id="headerVerifications">
                    <span class="material-symbols-outlined">verified</span>
                    <span id="verificationCountValue">0</span> verifications
                </span>
            </div>
        </div>
        <div class="header-center">
            <h1>Image Enhance Preset Selection</h1>
        </div>
        <div class="header-right">
            <button class="export-btn-minimal" onclick="exportYAML()">
                <span class="material-symbols-outlined">download</span>
                Export YAML
            </button>
        </div>
    </header>

    <main class="main">
        <div class="video-panel" id="videoPanel">
            <div class="video-container">
                <div class="video-wrapper">
                    <video id="video" src="recording/video.mp4" controls></video>
                </div>
                <button class="btn btn-add-step" onclick="openAddStepMode()">+ Add a Step</button>
            </div>
        </div>

        <div class="steps-panel" id="stepsPanel">
            <!-- Steps rendered by JS -->
        </div>
    </main>

    <!-- Add Step Mode (Full Page) - 3-Column Layout -->
    <div id="addStepMode" class="add-step-mode">
        <div class="add-step-header">
            <h2>Add a Step</h2>
            <div class="add-step-header-actions">
                <button class="btn btn-secondary" onclick="discardAddStep()">Discard</button>
                <button class="btn btn-primary" id="addStepAcceptBtn" onclick="acceptAddStep()" disabled>Add Step</button>
            </div>
        </div>

        <!-- Top bar: Insert After + Step Type -->
        <div class="add-step-top-bar">
            <div class="add-step-top-section">
                <label>Insert After:</label>
                <select id="addStepInsertAfter" class="add-step-select">
                    <option value="start">At the beginning</option>
                </select>
            </div>
            <div class="add-step-top-section">
                <label>Step Type:</label>
                <div class="add-step-type-buttons">
                    <button class="add-step-type-btn" data-type="tap" onclick="selectAddStepType('tap')"><span class="material-symbols-outlined">touch_app</span> Tap</button>
                    <button class="add-step-type-btn" data-type="swipe" onclick="selectAddStepType('swipe')"><span class="material-symbols-outlined">swipe_vertical</span> Swipe</button>
                    <button class="add-step-type-btn" data-type="wait_for" onclick="selectAddStepType('wait_for')"><span class="material-symbols-outlined">schedule</span> Wait For</button>
                    <button class="add-step-type-btn" data-type="type" onclick="selectAddStepType('type')"><span class="material-symbols-outlined">keyboard</span> Type</button>
                </div>
            </div>
        </div>

        <!-- Instruction text (video is in modal) -->
        <p id="addStepInstruction" class="add-step-instruction-bar">Select a step type, then click on frame slots below to capture from video</p>

        <!-- 3-Column Frame Layout - MD3 Styled -->
        <div class="add-step-columns" id="addStepColumns" style="display: none;">
            <!-- BEFORE Column -->
            <div class="add-step-column before">
                <div class="add-step-column-header">Before</div>
                <div class="add-step-frame-preview" id="addStepBeforePreview" onclick="openFramePickerModal('before')">
                    <span class="capture-hint">Click to capture frame</span>
                </div>
                <div class="add-step-column-content">
                    <div class="add-step-desc-wrapper">
                        <input type="text" class="add-step-desc-input" id="addStepBeforeDesc" placeholder="Describe the before state...">
                    </div>
                    <!-- Condition section -->
                    <div class="add-step-column-option">
                        <button class="btn-add-option" id="addStepConditionBtn" onclick="toggleAddStepCondition()">
                            <span class="material-symbols-outlined">rule</span>
                            + Condition
                        </button>
                        <div class="add-step-option-fields" id="addStepConditionFields" style="display: none;">
                            <select id="addStepConditionType" class="add-step-mini-select">
                                <option value="if_present">if_present</option>
                                <option value="if_absent">if_absent</option>
                                <option value="if_screen">if_screen</option>
                            </select>
                            <input type="text" id="addStepConditionValue" class="add-step-mini-input" placeholder="Element or description...">
                        </div>
                    </div>
                </div>
            </div>

            <!-- ACTION Column -->
            <div class="add-step-column action" id="addStepActionColumn">
                <div class="add-step-column-header">Action</div>
                <div class="add-step-frame-preview has-overlay" id="addStepActionPreview" onclick="openFramePickerModal('action')">
                    <span class="capture-hint">Click to capture &amp; set position</span>
                    <div class="add-step-tap-indicator" id="addStepTapIndicator" style="display: none;"></div>
                </div>

                <!-- Action-specific controls -->
                <div class="add-step-action-controls" id="addStepTapControls">
                    <div class="add-step-position-display">
                        <span class="label">Tap at:</span>
                        <span class="value" id="addStepTapPosition">Click on frame</span>
                    </div>
                </div>
                <div class="add-step-action-controls" id="addStepSwipeControls" style="display: none;">
                    <div class="add-step-position-display">
                        <span class="label">Start:</span>
                        <span class="value" id="addStepSwipeStart">Click on frame</span>
                    </div>
                    <div class="add-step-direction-buttons">
                        <button class="dir-btn" data-dir="up" onclick="selectAddStepDirection('up')"><span class="material-symbols-outlined">arrow_upward</span></button>
                        <button class="dir-btn" data-dir="down" onclick="selectAddStepDirection('down')"><span class="material-symbols-outlined">arrow_downward</span></button>
                        <button class="dir-btn" data-dir="left" onclick="selectAddStepDirection('left')"><span class="material-symbols-outlined">arrow_back</span></button>
                        <button class="dir-btn" data-dir="right" onclick="selectAddStepDirection('right')"><span class="material-symbols-outlined">arrow_forward</span></button>
                    </div>
                </div>
                <div class="add-step-action-controls" id="addStepWaitForControls" style="display: none;">
                    <div class="add-step-position-display">
                        <span class="label">Wait for:</span>
                    </div>
                    <input type="text" class="add-step-mini-input" id="addStepWaitForInput" placeholder="Element text to wait for..." oninput="updateAddStepReady()">
                </div>
                <div class="add-step-action-controls" id="addStepTypeControls" style="display: none;">
                    <div class="add-step-position-display">
                        <span class="label">Text:</span>
                    </div>
                    <input type="text" class="add-step-mini-input" id="addStepTypeInput" placeholder="Enter text to type..." oninput="updateAddStepReady()">
                    <label class="add-step-checkbox-label">
                        <input type="checkbox" id="addStepTypeSubmit">
                        <span>Press Enter after typing</span>
                    </label>
                </div>
            </div>

            <!-- AFTER Column -->
            <div class="add-step-column after">
                <div class="add-step-column-header">After</div>
                <div class="add-step-frame-preview" id="addStepAfterPreview" onclick="openFramePickerModal('after')">
                    <span class="capture-hint">Click to capture frame</span>
                </div>
                <div class="add-step-column-content">
                    <div class="add-step-desc-wrapper">
                        <input type="text" class="add-step-desc-input" id="addStepAfterDesc" placeholder="Describe the after state...">
                    </div>
                    <!-- Verification section -->
                    <div class="add-step-column-option">
                        <button class="btn-add-option" id="addStepVerificationBtn" onclick="toggleAddStepVerification()">
                            <span class="material-symbols-outlined">verified</span>
                            + Verification
                        </button>
                        <div class="add-step-option-fields" id="addStepVerificationFields" style="display: none;">
                            <input type="text" id="addStepVerificationValue" class="add-step-mini-input" placeholder="Describe expected screen state...">
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Frame Picker Modal - Redesigned (Outside addStepMode so it works for editing existing steps) -->
    <div id="framePickerModal" class="frame-picker-modal">
            <div class="frame-picker-content">
                <div class="frame-picker-header">
                    <div class="frame-picker-header-left">
                        <h3 id="framePickerTitle">Select Frame</h3>
                    </div>
                    <button class="frame-picker-close" onclick="closeFramePickerModal()">
                        <span class="material-symbols-outlined">close</span>
                    </button>
                </div>

                <div class="frame-picker-body">
                    <!-- Instruction hint (shown for action frames with tap/swipe) -->
                    <div class="frame-picker-hint" id="framePickerHint" style="display: none;">
                        <span class="material-symbols-outlined">touch_app</span>
                        <span id="framePickerHintText">Click on the video to pause and set tap position</span>
                    </div>

                    <!-- Video player with overlay -->
                    <div class="frame-picker-video-container">
                        <video id="framePickerVideo" src="recording/video.mp4" preload="auto" muted></video>
                        <div id="framePickerOverlay" class="frame-picker-overlay" onclick="handleFramePickerVideoClick(event)">
                            <!-- Tap indicator -->
                            <div class="frame-picker-tap-indicator" id="framePickerTapIndicator" style="display: none;"></div>
                            <!-- Swipe indicators -->
                            <div class="frame-picker-swipe-indicator start" id="framePickerSwipeStart" style="display: none;">
                                <span class="swipe-label">START</span>
                            </div>
                            <div class="frame-picker-swipe-indicator end" id="framePickerSwipeEnd" style="display: none;">
                                <span class="swipe-label">END</span>
                            </div>
                            <!-- Swipe line connecting start to end -->
                            <svg class="frame-picker-swipe-line" id="framePickerSwipeLine" style="display: none;">
                                <defs>
                                    <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                        <polygon points="0 0, 10 3.5, 0 7" fill="var(--md-tertiary)" />
                                    </marker>
                                </defs>
                                <line id="swipeLineElement" stroke="var(--md-tertiary)" stroke-width="3" stroke-dasharray="8,4" marker-end="url(#arrowhead)" />
                            </svg>
                        </div>
                        <!-- Time badge -->
                        <div class="video-time-badge" id="videoTimeBadge">
                            <span id="currentTimeDisplay">0:00</span>
                            <span class="time-separator">/</span>
                            <span id="durationDisplay">0:00</span>
                            <span class="time-separator">·</span>
                            <span class="frame-number">F<span id="frameNumberDisplay">0</span></span>
                        </div>
                        <!-- Play state indicator -->
                        <div class="video-play-indicator" id="videoPlayIndicator">
                            <span class="material-symbols-outlined">pause</span>
                        </div>
                        <!-- Position info overlay (for tap/swipe actions) -->
                        <div id="framePickerPositionInfo" class="frame-picker-position-info" style="display: none;">
                            <span class="material-symbols-outlined" id="framePickerPositionIcon">touch_app</span>
                            <span class="position-label" id="framePickerPositionLabel">TAP</span>
                            <span class="position-value" id="framePickerPositionValue">(0, 0)</span>
                            <button class="position-clear-btn" onclick="clearFramePickerPosition(); event.stopPropagation();">
                                <span class="material-symbols-outlined">close</span>
                            </button>
                        </div>
                    </div>

                    <!-- Timeline scrubber -->
                    <div class="frame-picker-scrubber">
                        <div class="scrubber-track" id="scrubberTrack" onclick="handleScrubberClick(event)">
                            <div class="scrubber-progress" id="scrubberProgress"></div>
                            <div class="scrubber-thumb" id="scrubberThumb"></div>
                            <!-- Thumbnail markers will be added here -->
                            <div class="scrubber-markers" id="scrubberMarkers"></div>
                        </div>
                    </div>
                </div>

                <div class="frame-picker-footer">
                    <button class="btn btn-secondary" onclick="closeFramePickerModal()">Cancel</button>
                    <button class="btn btn-primary" id="framePickerCaptureBtn" onclick="captureFromFramePicker()">
                        <span class="material-symbols-outlined">photo_camera</span>
                        Capture Frame
                    </button>
                </div>
            </div>
        </div>

    <script>
        // Data embedded during generation
        const testData = TEST_DATA_PLACEHOLDER;
        const availablePreconditions = testData.availablePreconditions || [];
        let steps = [...testData.steps];
        let activeStepId = null;
        let stepIdCounter = 0;

        // Utility: Escape HTML to prevent XSS
        function escapeHtml(str) {
            if (!str) return '';
            return String(str)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#039;');
        }

        // Initialize on load
        document.addEventListener('DOMContentLoaded', () => {
            renderSteps();
            initVideo();
            updateHeaderMeta();
            setTimeout(startFrameAnimations, 200);

            // Reposition gesture indicators after images may have loaded from cache
            setTimeout(() => {
                document.querySelectorAll('.gesture-indicator-wrapper').forEach(wrapper => {
                    const stepId = wrapper.dataset.stepId;
                    const img = wrapper.parentElement.querySelector('img');
                    if (img && stepId) {
                        positionIndicator(img, stepId);
                    }
                });
            }, 100);

            // Update header meta when video metadata loads
            const video = document.getElementById('video');
            if (video) {
                video.addEventListener('loadedmetadata', updateHeaderMeta);
            }
        });

        // Header stats are now handled by updateHeaderMeta()

        // Video Control
        function initVideo() {
            // Video controls are handled natively
        }

        function formatTime(seconds) {
            const m = Math.floor(seconds / 60);
            const s = Math.floor(seconds % 60);
            return `${m}:${s.toString().padStart(2, '0')}`;
        }

        function toggleVideoPanel() {
            const panel = document.getElementById('videoPanel');
            const toggle = document.getElementById('videoToggleBtn');
            const icon = document.getElementById('videoToggleIcon');

            panel.classList.toggle('collapsed');
            toggle.classList.toggle('collapsed');
            icon.textContent = panel.classList.contains('collapsed') ? '▶' : '◀';
        }

        function updateHeaderMeta() {
            // Update step count
            document.getElementById('stepCountValue').textContent = steps.length;

            // Update duration from video
            const video = document.getElementById('video');
            if (video && video.duration && !isNaN(video.duration)) {
                document.getElementById('durationValue').textContent = formatTime(video.duration);
            }

            // Count verifications
            let verificationCount = 0;
            steps.forEach(step => {
                if (step.verifications) {
                    verificationCount += step.verifications.length;
                }
            });
            document.getElementById('verificationCountValue').textContent = verificationCount;
        }

        function seekToStep(stepId) {
            const step = steps.find(s => s.id === stepId);
            if (step && step.timestamp !== undefined) {
                document.getElementById('video').currentTime = step.timestamp;
            }
            setActiveStep(stepId);
        }

        // Step Rendering
        function renderSteps() {
            const panel = document.getElementById('stepsPanel');
            panel.innerHTML = steps.map((step, index) => renderStepCard(step, index)).join('');
            updateHeaderMeta();
        }

        function renderStepCard(step, index) {
            const actionClass = step.action.replace('_', '');
            const isActive = step.id === activeStepId;
            const gestureInfo = getGestureInfo(step);

            return `
                <div class="step-card ${isActive ? 'active' : ''}" data-id="${step.id}" onclick="seekToStep('${step.id}')">
                    <!-- Header -->
                    <div class="step-header">
                        <div class="step-title">
                            <span class="step-number">${index + 1}</span>
                            <span class="gesture-badge ${actionClass}" title="${gestureInfo.tooltip}">${gestureInfo.icon} ${gestureInfo.label}</span>
                            <span class="step-action-title ${actionClass}" onclick="editStepTitle('${step.id}'); event.stopPropagation();" title="Click to edit">
                                ${step.analysis?.action || getStepTargetDisplay(step)}
                            </span>
                            ${step.conditional?.enabled ? '<span class="conditional-badge">if</span>' : ''}
                        </div>
                        <div class="step-controls">
                            <button onclick="moveStep('${step.id}', -1); event.stopPropagation();" title="Move up"><span class="material-symbols-outlined">keyboard_arrow_up</span></button>
                            <button onclick="moveStep('${step.id}', 1); event.stopPropagation();" title="Move down"><span class="material-symbols-outlined">keyboard_arrow_down</span></button>
                            <button class="delete" onclick="deleteStep('${step.id}'); event.stopPropagation();" title="Delete"><span class="material-symbols-outlined">close</span></button>
                        </div>
                    </div>

                    <div class="step-content">
                        <!-- 3-Column Story Layout: Before | Action | After -->
                        <!-- Condition in Before column, Verification in After column -->
                        ${renderFrames(step)}
                    </div>
                </div>
            `;
        }

        // Screen dimensions for percentage calculations
        const SCREEN_WIDTH = SCREEN_WIDTH_PLACEHOLDER;
        const SCREEN_HEIGHT = SCREEN_HEIGHT_PLACEHOLDER;

        function toPercent(value, max) {
            return Math.round((value / max) * 100);
        }

        function getGestureInfo(step) {
            const x = step.target?.x || 0;
            const y = step.target?.y || 0;
            const xPct = toPercent(x, SCREEN_WIDTH);
            const yPct = toPercent(y, SCREEN_HEIGHT);
            const dir = step.direction || 'up';

            switch (step.action) {
                case 'tap':
                    return {
                        icon: '<span class="material-symbols-outlined">touch_app</span>',
                        label: 'TAP',
                        tooltip: `Tap at ${xPct}%, ${yPct}% (${x}, ${y})`
                    };
                case 'swipe':
                    const arrows = {
                        up: '<span class="material-symbols-outlined">arrow_upward</span>',
                        down: '<span class="material-symbols-outlined">arrow_downward</span>',
                        left: '<span class="material-symbols-outlined">arrow_back</span>',
                        right: '<span class="material-symbols-outlined">arrow_forward</span>'
                    };
                    return {
                        icon: arrows[dir] || '<span class="material-symbols-outlined">swipe_vertical</span>',
                        label: `SWIPE ${dir.toUpperCase()}`,
                        tooltip: `Swipe ${dir}`
                    };
                case 'long_press':
                    return {
                        icon: '<span class="material-symbols-outlined">pan_tool_alt</span>',
                        label: 'LONG PRESS',
                        tooltip: `Long press at ${xPct}%, ${yPct}%`
                    };
                case 'double_tap':
                    return {
                        icon: '<span class="material-symbols-outlined">ads_click</span>',
                        label: 'DOUBLE TAP',
                        tooltip: `Double tap at ${xPct}%, ${yPct}%`
                    };
                case 'type':
                    return {
                        icon: '<span class="material-symbols-outlined">keyboard</span>',
                        label: 'TYPE',
                        tooltip: 'Type text'
                    };
                case 'verify_screen':
                    return {
                        icon: '<span class="material-symbols-outlined">check_circle</span>',
                        label: 'VERIFY',
                        tooltip: 'Verify screen state'
                    };
                case 'wait':
                case 'wait_for':
                    return {
                        icon: '<span class="material-symbols-outlined">schedule</span>',
                        label: 'WAIT',
                        tooltip: 'Wait'
                    };
                default:
                    return {
                        icon: '<span class="material-symbols-outlined">radio_button_unchecked</span>',
                        label: step.action.toUpperCase(),
                        tooltip: step.action
                    };
            }
        }

        function getStepTargetDisplay(step) {
            if (step.action === 'tap' || step.action === 'wait_for') {
                if (step.target?.text) {
                    return escapeHtml(step.target.text);
                }
                const xPct = toPercent(step.target?.x || 0, SCREEN_WIDTH);
                const yPct = toPercent(step.target?.y || 0, SCREEN_HEIGHT);
                return `at ${xPct}%, ${yPct}%`;
            }
            if (step.action === 'verify_screen') {
                return `"${escapeHtml(step.description || '')}"`;
            }
            if (step.action === 'wait') {
                return `${step.duration || 0}ms`;
            }
            if (step.action === 'swipe') {
                return step.direction || 'up';
            }
            return '';
        }

        function renderFrames(step) {
            if (!step.frames) return '<div class="no-frames">No frames available</div>';

            const beforeFrame = step.frames.before || '';
            const actionFrame = step.frames.action || beforeFrame;
            const afterFrame = step.frames.after || '';
            const analysis = step.analysis || {};

            // Calculate position as percentage for overlay
            const posX = step.target?.x || Math.round(SCREEN_WIDTH / 2);
            const posY = step.target?.y || Math.round(SCREEN_HEIGHT / 2);
            const posXPercent = (posX / SCREEN_WIDTH) * 100;
            const posYPercent = (posY / SCREEN_HEIGHT) * 100;

            // Render gesture-specific indicator
            function renderGestureIndicator() {
                if (step.action === 'tap') {
                    return `<div class="tap-indicator" style="left: ${posXPercent}%; top: ${posYPercent}%;"></div>`;
                }
                if (step.action === 'long_press') {
                    return `<div class="long-press-indicator" style="left: ${posXPercent}%; top: ${posYPercent}%;"></div>`;
                }
                if (step.action === 'double_tap') {
                    return `
                        <div class="double-tap-indicator" style="left: ${posXPercent}%; top: ${posYPercent}%;">
                            <div class="tap-circle tap-1"></div>
                            <div class="tap-circle tap-2"></div>
                        </div>
                    `;
                }
                if (step.action === 'swipe') {
                    const dir = step.direction || 'up';
                    const distance = step.distance || 400;
                    const distPercent = (distance / SCREEN_HEIGHT) * 100;
                    let endX = posXPercent, endY = posYPercent;
                    if (dir === 'up') endY = Math.max(5, posYPercent - distPercent);
                    if (dir === 'down') endY = Math.min(95, posYPercent + distPercent);
                    if (dir === 'left') endX = Math.max(5, posXPercent - (distance / SCREEN_WIDTH) * 100);
                    if (dir === 'right') endX = Math.min(95, posXPercent + (distance / SCREEN_WIDTH) * 100);

                    // Calculate arrow rotation (accounting for phone aspect ratio ~9:19.5)
                    const aspectRatio = SCREEN_WIDTH / SCREEN_HEIGHT; // ~0.46
                    const dx = (endX - posXPercent) * aspectRatio;
                    const dy = endY - posYPercent;
                    const angle = Math.atan2(dy, dx) * (180 / Math.PI);

                    return '<div class="swipe-indicator" data-start-x="' + posXPercent + '" data-start-y="' + posYPercent + '" data-end-x="' + endX + '" data-end-y="' + endY + '" data-angle="' + angle + '" style="left: 0; top: 0; width: 100%; height: 100%;">' +
                        '<div class="swipe-trajectory-line"></div>' +
                        '<div class="swipe-dot" style="--start-x: ' + posXPercent + '%; --start-y: ' + posYPercent + '%; --end-x: ' + endX + '%; --end-y: ' + endY + '%;"></div>' +
                    '</div>';
                }
                return '';
            }

            // Render gesture info for action column
            function renderGestureInfo() {
                const x = step.target?.x || 0;
                const y = step.target?.y || 0;
                const xPct = toPercent(x, SCREEN_WIDTH);
                const yPct = toPercent(y, SCREEN_HEIGHT);

                if (step.action === 'tap' || step.action === 'long_press' || step.action === 'double_tap') {
                    return `
                        <div class="frame-gesture-info gesture-grid">
                            <div class="gesture-cell full-width">
                                <span class="gesture-label">Tap Target:</span>
                                <input type="text" value="${escapeHtml(step.target?.text || '')}"
                                       onchange="updateStepTarget('${step.id}', this.value); event.stopPropagation();"
                                       onclick="event.stopPropagation();"
                                       placeholder="Element text">
                            </div>
                            <div class="gesture-cell">
                                <span class="gesture-label">X:</span>
                                <input type="number" value="${xPct}"
                                       onchange="updateTapPosition('${step.id}', 'x', this.value); event.stopPropagation();"
                                       onclick="event.stopPropagation();"
                                       min="0" max="100" step="1">
                                <span class="gesture-unit">%</span>
                            </div>
                            <div class="gesture-cell">
                                <span class="gesture-label">Y:</span>
                                <input type="number" value="${yPct}"
                                       onchange="updateTapPosition('${step.id}', 'y', this.value); event.stopPropagation();"
                                       onclick="event.stopPropagation();"
                                       min="0" max="100" step="1">
                                <span class="gesture-unit">%</span>
                            </div>
                            ${step.action === 'long_press' ? `
                                <div class="gesture-cell full-width">
                                    <span class="gesture-label">Duration:</span>
                                    <input type="number" value="${step.duration || 500}"
                                           onchange="updateStepDuration('${step.id}', this.value); event.stopPropagation();"
                                           onclick="event.stopPropagation();"
                                           min="300" step="100">
                                    <span class="gesture-unit">ms</span>
                                </div>
                            ` : ''}
                        </div>
                    `;
                }

                if (step.action === 'swipe') {
                    const dir = step.direction || 'up';
                    const distance = step.distance || 400;
                    // Convert distance to percentage (relative to screen height for up/down, width for left/right)
                    const isVertical = (dir === 'up' || dir === 'down');
                    const distPct = isVertical
                        ? Math.round((distance / SCREEN_HEIGHT) * 100)
                        : Math.round((distance / SCREEN_WIDTH) * 100);
                    return `
                        <div class="frame-gesture-info gesture-grid">
                            <div class="gesture-cell">
                                <span class="gesture-label">Direction:</span>
                                <select onchange="updateSwipeDirection('${step.id}', this.value); event.stopPropagation();"
                                        onclick="event.stopPropagation();">
                                    <option value="up" ${dir === 'up' ? 'selected' : ''}>Up</option>
                                    <option value="down" ${dir === 'down' ? 'selected' : ''}>Down</option>
                                    <option value="left" ${dir === 'left' ? 'selected' : ''}>Left</option>
                                    <option value="right" ${dir === 'right' ? 'selected' : ''}>Right</option>
                                </select>
                            </div>
                            <div class="gesture-cell">
                                <span class="gesture-label">Start X:</span>
                                <input type="number" value="${xPct}"
                                       onchange="updateSwipeStart('${step.id}', 'x', this.value); event.stopPropagation();"
                                       onclick="event.stopPropagation();"
                                       min="0" max="100" step="1">
                                <span class="gesture-unit">%</span>
                            </div>
                            <div class="gesture-cell">
                                <span class="gesture-label">Start Y:</span>
                                <input type="number" value="${yPct}"
                                       onchange="updateSwipeStart('${step.id}', 'y', this.value); event.stopPropagation();"
                                       onclick="event.stopPropagation();"
                                       min="0" max="100" step="1">
                                <span class="gesture-unit">%</span>
                            </div>
                            <div class="gesture-cell">
                                <span class="gesture-label">Distance:</span>
                                <input type="number" value="${distPct}"
                                       onchange="updateSwipeDistancePercent('${step.id}', this.value); event.stopPropagation();"
                                       onclick="event.stopPropagation();"
                                       min="5" max="90" step="5">
                                <span class="gesture-unit">%</span>
                            </div>
                        </div>
                    `;
                }

                if (step.action === 'type') {
                    const tapCountInfo = step.tapCount ? ` <span class="gesture-info-secondary">(${step.tapCount} keystrokes)</span>` : '';
                    return `
                        <div class="frame-gesture-info">
                            <div class="gesture-row">
                                <span class="gesture-label">Text:${tapCountInfo}</span>
                                <input type="text" value="${escapeHtml(step.text || '')}"
                                       onchange="updateStepText('${step.id}', this.value); event.stopPropagation();"
                                       onclick="event.stopPropagation();"
                                       style="flex: 1;">
                            </div>
                            <div class="gesture-row">
                                <span class="gesture-label">Submit:</span>
                                <input type="checkbox" ${step.submit ? 'checked' : ''}
                                       onchange="updateStepSubmit('${step.id}', this.checked); event.stopPropagation();"
                                       onclick="event.stopPropagation();">
                            </div>
                        </div>
                    `;
                }

                return '';
            }

            const showActionFrame = ['tap', 'long_press', 'double_tap', 'swipe'].includes(step.action);
            const beforeText = analysis.before || '';
            const actionText = analysis.action || '';
            const afterText = analysis.after || '';

            // Render conditions list
            function renderConditionsList() {
                const conditions = step.conditions || [];
                if (conditions.length === 0) return '';

                return `
                    <div class="conditions-list">
                        ${conditions.map((cond, idx) => `
                            <div class="condition-item">
                                <span class="condition-item-text">
                                    <span class="material-symbols-outlined">bolt</span>
                                    <span class="condition-item-type">${cond.type}</span>
                                    <span class="condition-item-value">"${escapeHtml(cond.value)}"</span>
                                </span>
                                <button class="condition-item-remove" onclick="removeConditionFromStep('${step.id}', ${idx}); event.stopPropagation();" title="Remove"><span class="material-symbols-outlined">close</span></button>
                            </div>
                        `).join('')}
                    </div>
                `;
            }

            // Render add condition form
            function renderAddConditionForm() {
                if (!step._addingCondition) return '';

                return `
                    <div class="inline-add-form" id="add-condition-form-${step.id}">
                        <label>Type:</label>
                        <select id="condition-type-${step.id}" onclick="event.stopPropagation()">
                            <option value="if_present">if_present</option>
                            <option value="if_absent">if_absent</option>
                            <option value="if_screen">if_screen</option>
                        </select>
                        <label>Value:</label>
                        <input type="text" id="condition-value-input-${step.id}" placeholder="Element text or screen description..." onclick="event.stopPropagation()">
                        <div class="inline-add-form-buttons">
                            <button class="btn-cancel" onclick="cancelAddCondition('${step.id}'); event.stopPropagation();">Cancel</button>
                            <button class="btn-add" onclick="confirmAddCondition('${step.id}'); event.stopPropagation();">Add</button>
                        </div>
                    </div>
                `;
            }

            // Render verifications list
            function renderVerificationsList() {
                const verifications = step.verifications || [];
                if (verifications.length === 0) return '';

                return `
                    <div class="verifications-list">
                        ${verifications.map((ver, idx) => `
                            <div class="verification-item">
                                <span class="verification-item-text">
                                    <span class="material-symbols-outlined">check</span>
                                    <span class="verification-item-value">"${escapeHtml(ver.description)}"</span>
                                </span>
                                <button class="verification-item-remove" onclick="removeVerificationFromStep('${step.id}', ${idx}); event.stopPropagation();" title="Remove"><span class="material-symbols-outlined">close</span></button>
                            </div>
                        `).join('')}
                    </div>
                `;
            }

            // Render add verification form
            function renderAddVerificationForm() {
                if (!step._addingVerification) return '';

                return `
                    <div class="inline-add-form" id="add-verification-form-${step.id}">
                        <label>Verify that:</label>
                        <input type="text" id="verification-value-input-${step.id}" placeholder="Describe expected screen state..." onclick="event.stopPropagation()">
                        <div class="inline-add-form-buttons">
                            <button class="btn-cancel" onclick="cancelAddVerification('${step.id}'); event.stopPropagation();">Cancel</button>
                            <button class="btn-add" onclick="confirmAddVerification('${step.id}'); event.stopPropagation();">Add</button>
                        </div>
                    </div>
                `;
            }

            return `
                <div class="step-frames">
                    <!-- BEFORE Column -->
                    <div class="frame-column before">
                        <div class="frame-column-header">Before</div>
                        <div class="frame-image-container clickable" onclick="openFramePickerForStep('${step.id}', 'before'); event.stopPropagation();" title="Click to change frame">
                            ${beforeFrame ? `<img src="${beforeFrame}">` : '<em>Click to select</em>'}
                            <div class="frame-edit-hint"><span class="material-symbols-outlined">edit</span></div>
                        </div>
                        <div class="frame-description" contenteditable="true"
                             onclick="event.stopPropagation();"
                             onblur="saveAnalysisField('${step.id}', 'before', this.innerText)"
                             data-placeholder="Click to add description">${beforeText ? escapeHtml(beforeText) : ''}</div>
                        <!-- Conditions list -->
                        ${renderConditionsList()}
                        <!-- Spacer to push button to bottom -->
                        <div class="column-spacer"></div>
                        <!-- Add condition form or button -->
                        ${step._addingCondition ? renderAddConditionForm() : `
                            <button class="btn btn-add-inline" onclick="showAddConditionForm('${step.id}'); event.stopPropagation();">+ Condition</button>
                        `}
                    </div>

                    <!-- ACTION Column -->
                    <div class="frame-column action">
                        <div class="frame-column-header">Action</div>
                        <div class="frame-image-container clickable" onclick="openFramePickerForStep('${step.id}', 'action'); event.stopPropagation();" title="Click to change frame">
                            ${actionFrame && showActionFrame ? `
                                <img src="${actionFrame}" onload="positionIndicator(this, '${step.id}')">
                                <div class="gesture-indicator-wrapper" data-step-id="${step.id}" data-x="${posXPercent}" data-y="${posYPercent}" data-action="${step.action}" data-direction="${step.direction || 'up'}">
                                    ${renderGestureIndicator()}
                                </div>
                            ` : '<em>Click to select</em>'}
                            <div class="frame-edit-hint"><span class="material-symbols-outlined">edit</span></div>
                        </div>
                        <div class="frame-description" contenteditable="true"
                             onclick="event.stopPropagation();"
                             onblur="saveAnalysisField('${step.id}', 'action', this.innerText)"
                             data-placeholder="Click to add description">${actionText ? escapeHtml(actionText) : ''}</div>
                        ${renderGestureInfo()}
                    </div>

                    <!-- AFTER Column -->
                    <div class="frame-column after">
                        <div class="frame-column-header">After</div>
                        <div class="frame-image-container clickable" onclick="openFramePickerForStep('${step.id}', 'after'); event.stopPropagation();" title="Click to change frame">
                            ${afterFrame ? `<img src="${afterFrame}">` : '<em>Click to select</em>'}
                            <div class="frame-edit-hint"><span class="material-symbols-outlined">edit</span></div>
                        </div>
                        <div class="frame-description" contenteditable="true"
                             onclick="event.stopPropagation();"
                             onblur="saveAnalysisField('${step.id}', 'after', this.innerText)"
                             data-placeholder="Click to add description">${afterText ? escapeHtml(afterText) : ''}</div>
                        <!-- Verifications list -->
                        ${renderVerificationsList()}
                        <!-- Suggested verification prompt (inline in AFTER column) -->
                        ${step.suggestedVerification && !step.verificationAdded && !(step.verifications?.length > 0) ? `
                            <div class="suggested-verification-inline">
                                <div class="suggestion-inline-header">
                                    <span class="material-symbols-outlined">lightbulb</span>
                                    Suggested
                                </div>
                                <div class="suggestion-inline-text">"${escapeHtml(step.suggestedVerification)}"</div>
                                <div class="suggestion-inline-actions">
                                    <button class="btn-suggestion-add" onclick="acceptSuggestion('${step.id}'); event.stopPropagation();" title="Add this verification">
                                        <span class="material-symbols-outlined">add</span>
                                    </button>
                                    <button class="btn-suggestion-edit" onclick="editSuggestion('${step.id}'); event.stopPropagation();" title="Edit">
                                        <span class="material-symbols-outlined">edit</span>
                                    </button>
                                    <button class="btn-suggestion-skip" onclick="skipSuggestion('${step.id}'); event.stopPropagation();" title="Skip">
                                        <span class="material-symbols-outlined">close</span>
                                    </button>
                                </div>
                            </div>
                        ` : ''}
                        <!-- Spacer to push button to bottom -->
                        <div class="column-spacer"></div>
                        <!-- Add verification form or button (hidden if suggested verification is showing) -->
                        ${step._addingVerification ? renderAddVerificationForm() :
                            (step.suggestedVerification && !step.verificationAdded && !(step.verifications?.length > 0)) ? '' : `
                            <button class="btn btn-add-inline" onclick="showAddVerificationForm('${step.id}'); event.stopPropagation();">+ Verification</button>
                        `}
                    </div>
                </div>
            `;
        }

        function renderGestureConfig(step) {
            const x = step.target?.x || 0;
            const y = step.target?.y || 0;
            const xPct = toPercent(x, SCREEN_WIDTH);
            const yPct = toPercent(y, SCREEN_HEIGHT);

            // TAP gestures
            if (step.action === 'tap') {
                return `
                    <div class="gesture-config">
                        <div class="config-group">
                            <span class="config-label">Target:</span>
                            <input type="text" value="${escapeHtml(step.target?.text || '')}"
                                   onchange="updateStepTarget('${step.id}', this.value); event.stopPropagation();"
                                   placeholder="Element text">
                        </div>
                        <div class="config-group">
                            <span class="config-label">Position:</span>
                            <span class="config-value">${xPct}%, ${yPct}%</span>
                            <span class="config-label" style="opacity: 0.5">(${x}, ${y})</span>
                        </div>
                        <div class="config-group">
                            <span class="config-label">Wait after:</span>
                            <input type="number" value="${step.waitAfter || 0}"
                                   onchange="updateStepWait('${step.id}', this.value); event.stopPropagation();"
                                   min="0" step="100">
                            <span class="config-label">ms</span>
                        </div>
                    </div>
                `;
            }

            // SWIPE gestures
            if (step.action === 'swipe') {
                const dir = step.direction || 'up';
                const distance = step.distance || 400;
                const distPct = Math.round((distance / SCREEN_HEIGHT) * 100);
                return `
                    <div class="gesture-config">
                        <div class="config-group">
                            <span class="config-label">Direction:</span>
                            <select onchange="updateSwipeDirection('${step.id}', this.value); event.stopPropagation();">
                                <option value="up" ${dir === 'up' ? 'selected' : ''}>⬆️ Up</option>
                                <option value="down" ${dir === 'down' ? 'selected' : ''}>⬇️ Down</option>
                                <option value="left" ${dir === 'left' ? 'selected' : ''}>⬅️ Left</option>
                                <option value="right" ${dir === 'right' ? 'selected' : ''}>➡️ Right</option>
                            </select>
                        </div>
                        <div class="config-group">
                            <span class="config-label">Start:</span>
                            <span class="config-value">${xPct}%, ${yPct}%</span>
                        </div>
                        <div class="config-group">
                            <span class="config-label">Distance:</span>
                            <input type="number" value="${distance}"
                                   onchange="updateSwipeDistance('${step.id}', this.value); event.stopPropagation();"
                                   min="100" step="50">
                            <span class="config-label">px (${distPct}%)</span>
                        </div>
                    </div>
                `;
            }

            // LONG PRESS gestures
            if (step.action === 'long_press') {
                const duration = step.duration || 500;
                return `
                    <div class="gesture-config">
                        <div class="config-group">
                            <span class="config-label">Target:</span>
                            <input type="text" value="${escapeHtml(step.target?.text || '')}"
                                   onchange="updateStepTarget('${step.id}', this.value); event.stopPropagation();"
                                   placeholder="Element text">
                        </div>
                        <div class="config-group">
                            <span class="config-label">Position:</span>
                            <span class="config-value">${xPct}%, ${yPct}%</span>
                        </div>
                        <div class="config-group">
                            <span class="config-label">Duration:</span>
                            <input type="number" value="${duration}"
                                   onchange="updateStepDuration('${step.id}', this.value); event.stopPropagation();"
                                   min="300" step="100">
                            <span class="config-label">ms</span>
                        </div>
                    </div>
                `;
            }

            // DOUBLE TAP gestures
            if (step.action === 'double_tap') {
                return `
                    <div class="gesture-config">
                        <div class="config-group">
                            <span class="config-label">Target:</span>
                            <input type="text" value="${escapeHtml(step.target?.text || '')}"
                                   onchange="updateStepTarget('${step.id}', this.value); event.stopPropagation();"
                                   placeholder="Element text">
                        </div>
                        <div class="config-group">
                            <span class="config-label">Position:</span>
                            <span class="config-value">${xPct}%, ${yPct}%</span>
                        </div>
                    </div>
                `;
            }

            // TYPE gestures
            if (step.action === 'type') {
                const text = step.text || step.target?.text || '';
                const tapCountInfo = step.tapCount ? `<span class="config-label" style="color: #666;">(${step.tapCount} keystrokes)</span>` : '';
                return `
                    <div class="gesture-config">
                        <div class="config-group" style="flex: 1;">
                            <span class="config-label">Text:</span>
                            <input type="text" value="${escapeHtml(text)}"
                                   onchange="updateTypeText('${step.id}', this.value); event.stopPropagation();"
                                   style="width: 200px;">
                            ${tapCountInfo}
                        </div>
                        <div class="config-group">
                            <span class="config-label">Submit:</span>
                            <input type="checkbox" ${step.submit ? 'checked' : ''}
                                   onchange="updateTypeSubmit('${step.id}', this.checked); event.stopPropagation();">
                            <span class="config-label">(press Enter)</span>
                        </div>
                    </div>
                `;
            }

            // VERIFY_SCREEN
            if (step.action === 'verify_screen') {
                return `
                    <div class="gesture-config">
                        <div class="config-group" style="flex: 1;">
                            <span class="config-label">Description:</span>
                            <input type="text" value="${escapeHtml(step.description || '')}"
                                   onchange="updateStepDescription('${step.id}', this.value); event.stopPropagation();"
                                   style="width: 300px;" placeholder="What should the screen show?">
                        </div>
                    </div>
                `;
            }

            // WAIT_FOR
            if (step.action === 'wait_for') {
                return `
                    <div class="gesture-config">
                        <div class="config-group">
                            <span class="config-label">Wait for element:</span>
                            <input type="text" value="${escapeHtml(step.target?.text || '')}"
                                   onchange="updateStepTarget('${step.id}', this.value); event.stopPropagation();">
                        </div>
                        <div class="config-group">
                            <span class="config-label">Timeout:</span>
                            <input type="number" value="${step.timeout || 10}"
                                   onchange="updateStepTimeout('${step.id}', this.value); event.stopPropagation();"
                                   min="1" max="60">
                            <span class="config-label">s</span>
                        </div>
                    </div>
                `;
            }

            // WAIT
            if (step.action === 'wait') {
                return `
                    <div class="gesture-config">
                        <div class="config-group">
                            <span class="config-label">Duration:</span>
                            <input type="number" value="${step.duration || 1000}"
                                   onchange="updateStepDuration('${step.id}', this.value); event.stopPropagation();"
                                   min="100" step="100">
                            <span class="config-label">ms</span>
                        </div>
                    </div>
                `;
            }

            return '';
        }

        // Frame animation system
        const frameAnimations = new Map();

        function startFrameAnimations() {
            document.querySelectorAll('.frame-wrapper[data-frames]').forEach(wrapper => {
                const stepId = wrapper.dataset.stepId;
                if (frameAnimations.has(stepId)) return; // Already animating

                const imgs = wrapper.querySelectorAll('img');
                if (imgs.length <= 1) return;

                let currentIndex = 0;
                const interval = setInterval(() => {
                    imgs[currentIndex].classList.remove('active');
                    currentIndex = (currentIndex + 1) % imgs.length;
                    imgs[currentIndex].classList.add('active');
                }, 400); // 400ms per frame

                frameAnimations.set(stepId, interval);
            });
        }

        function stopFrameAnimations() {
            frameAnimations.forEach((interval, stepId) => {
                clearInterval(interval);
            });
            frameAnimations.clear();
        }

        // Restart animations after re-render
        const originalRenderSteps = renderSteps;
        renderSteps = function() {
            stopFrameAnimations();
            const panel = document.getElementById('stepsPanel');
            panel.innerHTML = steps.map((step, index) => renderStepCard(step, index)).join('');
            updateHeaderMeta();
            setTimeout(startFrameAnimations, 100);
        };

        function editAnalysisField(stepId, field) {
            const step = steps.find(s => s.id === stepId);
            if (!step) return;

            if (!step.analysis) step.analysis = {};
            const currentValue = step.analysis[field] || '';
            const fieldLabels = { before: 'Before', action: 'Action', after: 'After' };

            showMd3Dialog(
                'Edit Description',
                fieldLabels[field] + ' description',
                currentValue,
                (newValue) => {
                    if (newValue !== null && newValue.trim() !== '') {
                        step.analysis[field] = newValue.trim();
                        renderSteps();
                    }
                }
            );
        }

        // Direct inline save for contenteditable descriptions
        function saveAnalysisField(stepId, field, value) {
            const step = steps.find(s => s.id === stepId);
            if (!step) return;

            if (!step.analysis) step.analysis = {};
            step.analysis[field] = value.trim();
        }

        function renderSuggestion(step) {
            return `
                <div class="step-suggestion">
                    <div class="suggestion-header">💡 Suggested verification</div>
                    <div class="suggestion-text">verify_screen: "${escapeHtml(step.suggestedVerification)}"</div>
                    <div class="suggestion-actions">
                        <button class="btn btn-primary" onclick="acceptSuggestion('${step.id}'); event.stopPropagation();">+ Add</button>
                        <button class="btn btn-secondary" onclick="editSuggestion('${step.id}'); event.stopPropagation();">Edit</button>
                        <button class="btn btn-secondary" onclick="skipSuggestion('${step.id}'); event.stopPropagation();">Skip</button>
                    </div>
                </div>
            `;
        }

        function renderConditional(step) {
            const isConditional = step.conditional && step.conditional.enabled;
            const condType = step.conditional?.type || 'if_present';
            // Collapsed by default unless conditional is enabled
            const isCollapsed = !isConditional;

            return `
                <div class="step-conditional ${isCollapsed ? 'collapsed' : ''}" data-step-id="${step.id}">
                    <div class="conditional-header" onclick="toggleConditionalExpand('${step.id}'); event.stopPropagation();">
                        <span class="conditional-label">
                            <span class="material-symbols-outlined">bolt</span> CONDITIONAL
                            <span class="conditional-expand-hint">(click to expand)</span>
                        </span>
                        <input type="checkbox" class="conditional-toggle"
                               ${isConditional ? 'checked' : ''}
                               onchange="toggleConditional('${step.id}', this.checked); event.stopPropagation();"
                               onclick="event.stopPropagation();">
                    </div>
                    <div class="conditional-config" ${isCollapsed ? 'style="display:none;"' : ''}>
                        <div class="conditional-field">
                            <label>Type:</label>
                            <select onchange="updateConditionalType('${step.id}', this.value); event.stopPropagation();">
                                <option value="if_present" ${condType === 'if_present' ? 'selected' : ''}>if_present</option>
                                <option value="if_absent" ${condType === 'if_absent' ? 'selected' : ''}>if_absent</option>
                                <option value="if_all_present" ${condType === 'if_all_present' ? 'selected' : ''}>if_all_present</option>
                                <option value="if_any_present" ${condType === 'if_any_present' ? 'selected' : ''}>if_any_present</option>
                                <option value="if_screen" ${condType === 'if_screen' ? 'selected' : ''}>if_screen</option>
                                <option value="if_precondition" ${condType === 'if_precondition' ? 'selected' : ''}>if_precondition</option>
                            </select>
                        </div>
                        <div class="conditional-field cond-value-field">
                            ${getConditionalValueInput(step)}
                        </div>
                    </div>
                </div>
            `;
        }

        function setActiveStep(stepId) {
            activeStepId = stepId;
            document.querySelectorAll('.step-card').forEach(card => {
                card.classList.toggle('active', card.dataset.id === stepId);
            });
        }

        // Step Editing Functions
        function moveStep(stepId, direction) {
            const index = steps.findIndex(s => s.id === stepId);
            const newIndex = index + direction;
            if (newIndex < 0 || newIndex >= steps.length) return;

            [steps[index], steps[newIndex]] = [steps[newIndex], steps[index]];
            renderSteps();
        }

        function deleteStep(stepId) {
            if (!confirm('Delete this step?')) return;
            steps = steps.filter(s => s.id !== stepId);
            renderSteps();
        }

        function editStepTitle(stepId) {
            const step = steps.find(s => s.id === stepId);
            if (!step) return;

            const currentTitle = step.analysis?.action || (step.action + ': ' + getStepTargetDisplay(step));

            showMd3Dialog(
                'Edit Step Title',
                'Step title',
                currentTitle,
                (newTitle) => {
                    if (newTitle !== null && newTitle.trim() !== '') {
                        if (!step.analysis) step.analysis = {};
                        step.analysis.action = newTitle.trim();
                        renderSteps();
                    }
                }
            );
        }

        function updateStepTarget(stepId, value) {
            const step = steps.find(s => s.id === stepId);
            if (step) {
                if (!step.target) step.target = {};
                step.target.text = value;
            }
        }

        function updateTapPosition(stepId, axis, value) {
            const step = steps.find(s => s.id === stepId);
            if (step) {
                const pct = Math.max(0, Math.min(100, parseInt(value) || 50));
                if (!step.target) step.target = { x: 0, y: 0 };
                if (axis === 'x') {
                    step.target.x = Math.round((pct / 100) * SCREEN_WIDTH);
                } else {
                    step.target.y = Math.round((pct / 100) * SCREEN_HEIGHT);
                }
                renderSteps();
            }
        }

        function updateStepWait(stepId, value) {
            const step = steps.find(s => s.id === stepId);
            if (step) step.waitAfter = parseInt(value) || 0;
        }

        function updateStepDescription(stepId, value) {
            const step = steps.find(s => s.id === stepId);
            if (step) step.description = value;
        }

        function updateStepTimeout(stepId, value) {
            const step = steps.find(s => s.id === stepId);
            if (step) step.timeout = parseInt(value) || 10;
        }

        function updateStepDuration(stepId, value) {
            const step = steps.find(s => s.id === stepId);
            if (step) step.duration = parseInt(value) || 1000;
        }

        function updateStepText(stepId, value) {
            const step = steps.find(s => s.id === stepId);
            if (step) step.text = value;
        }

        function updateStepSubmit(stepId, value) {
            const step = steps.find(s => s.id === stepId);
            if (step) step.submit = value;
        }

        function updateSwipeDirection(stepId, value) {
            const step = steps.find(s => s.id === stepId);
            if (step) {
                step.direction = value;
                renderSteps();
            }
        }

        function updateSwipeDistance(stepId, value) {
            const step = steps.find(s => s.id === stepId);
            if (step) {
                step.distance = parseInt(value) || 400;
                renderSteps();
            }
        }

        function updateSwipeStart(stepId, axis, value) {
            const step = steps.find(s => s.id === stepId);
            if (step) {
                const pct = Math.max(0, Math.min(100, parseInt(value) || 50));
                if (!step.target) step.target = { x: 0, y: 0 };
                if (axis === 'x') {
                    step.target.x = Math.round((pct / 100) * SCREEN_WIDTH);
                } else {
                    step.target.y = Math.round((pct / 100) * SCREEN_HEIGHT);
                }
                renderSteps();
            }
        }

        function updateSwipeDistancePercent(stepId, value) {
            const step = steps.find(s => s.id === stepId);
            if (step) {
                const pct = Math.max(5, Math.min(90, parseInt(value) || 17));
                const dir = step.direction || 'up';
                const isVertical = (dir === 'up' || dir === 'down');
                // Convert percentage to pixels
                step.distance = isVertical
                    ? Math.round((pct / 100) * SCREEN_HEIGHT)
                    : Math.round((pct / 100) * SCREEN_WIDTH);
                renderSteps();
            }
        }

        function updateTypeText(stepId, value) {
            const step = steps.find(s => s.id === stepId);
            if (step) {
                step.text = value;
                if (!step.target) step.target = {};
                step.target.text = value;
                renderSteps();
            }
        }

        function updateTypeSubmit(stepId, checked) {
            const step = steps.find(s => s.id === stepId);
            if (step) {
                step.submit = checked;
                renderSteps();
            }
        }

        // Conditional Management
        function toggleConditionalExpand(stepId) {
            const conditionalDiv = document.querySelector(`.step-conditional[data-step-id="${stepId}"]`);
            if (conditionalDiv) {
                const isCollapsed = conditionalDiv.classList.contains('collapsed');
                conditionalDiv.classList.toggle('collapsed');
                const config = conditionalDiv.querySelector('.conditional-config');
                if (config) {
                    config.style.display = isCollapsed ? 'flex' : 'none';
                }
            }
        }

        function toggleConditional(stepId, enabled) {
            const step = steps.find(s => s.id === stepId);
            if (step) {
                if (!step.conditional) {
                    step.conditional = {
                        enabled: false,
                        type: 'if_present',
                        value: step.target?.text || ''
                    };
                }
                step.conditional.enabled = enabled;
                renderSteps();
            }
        }

        function updateConditionalType(stepId, type) {
            const step = steps.find(s => s.id === stepId);
            if (step) {
                // Create conditional object if it doesn't exist
                if (!step.conditional) {
                    step.conditional = {
                        enabled: false,
                        type: 'if_present',
                        value: step.target?.text || ''
                    };
                }
                step.conditional.type = type;
                // Clear value when switching types (different inputs needed)
                step.conditional.value = '';

                // Update just the value field, not the whole UI
                const conditionalDiv = document.querySelector(`.step-conditional[data-step-id="${stepId}"]`);
                if (conditionalDiv) {
                    const valueField = conditionalDiv.querySelector('.cond-value-field');
                    if (valueField) {
                        valueField.innerHTML = getConditionalValueInput(step);
                    }
                }
            }
        }

        function getConditionalValueInput(step) {
            const condType = step.conditional?.type || 'if_present';
            const condValue = step.conditional?.value || '';
            const stepId = step.id;

            switch (condType) {
                case 'if_precondition':
                    return `
                        <label>Precondition:</label>
                        <select class="cond-value-input" onchange="updateConditionalValue('${stepId}', this.value); event.stopPropagation();">
                            <option value="">Select precondition...</option>
                            ${availablePreconditions.map(p =>
                                `<option value="${escapeHtml(p)}" ${condValue === p ? 'selected' : ''}>${escapeHtml(p)}</option>`
                            ).join('')}
                        </select>
                    `;
                case 'if_screen':
                    return `
                        <label>Screen State:</label>
                        <input type="text" class="cond-value-input cond-screen-input" value="${escapeHtml(condValue)}"
                               onchange="updateConditionalValue('${stepId}', this.value); event.stopPropagation();"
                               placeholder="Describe expected screen state...">
                    `;
                case 'if_all_present':
                case 'if_any_present':
                    return `
                        <label>Elements:</label>
                        <input type="text" class="cond-value-input" value="${escapeHtml(condValue)}"
                               onchange="updateConditionalValue('${stepId}', this.value); event.stopPropagation();"
                               placeholder="Element1, Element2, ...">
                    `;
                case 'if_present':
                case 'if_absent':
                default:
                    return `
                        <label>Element:</label>
                        <input type="text" class="cond-value-input" value="${escapeHtml(condValue)}"
                               onchange="updateConditionalValue('${stepId}', this.value); event.stopPropagation();"
                               placeholder="Button text or label...">
                    `;
            }
        }

        function updateConditionalValue(stepId, value) {
            const step = steps.find(s => s.id === stepId);
            if (step && step.conditional) {
                step.conditional.value = value;
            }
        }

        // Suggestion Functions
        function acceptSuggestion(stepId) {
            const stepIndex = steps.findIndex(s => s.id === stepId);
            const step = steps[stepIndex];
            if (!step || !step.suggestedVerification) return;

            const newStep = {
                id: 'verify_' + Date.now() + '_' + (++stepIdCounter),
                action: 'verify_screen',
                description: step.suggestedVerification,
                timestamp: step.timestamp
            };

            steps.splice(stepIndex + 1, 0, newStep);
            step.verificationAdded = true;
            renderSteps();
        }

        function editSuggestion(stepId) {
            const step = steps.find(s => s.id === stepId);
            if (!step) return;

            showMd3Dialog(
                'Edit Verification',
                'Expected screen state',
                step.suggestedVerification,
                (newDesc) => {
                    if (newDesc !== null && newDesc.trim() !== '') {
                        step.suggestedVerification = newDesc.trim();
                        acceptSuggestion(stepId);
                    }
                }
            );
        }

        function skipSuggestion(stepId) {
            const step = steps.find(s => s.id === stepId);
            if (step) {
                step.verificationAdded = true;
                renderSteps();
            }
        }

        // Add Step Functions
        function addVerifyAfterStep(stepId) {
            const stepIndex = steps.findIndex(s => s.id === stepId);
            if (stepIndex === -1) return;

            const step = steps[stepIndex];

            showMd3Dialog(
                'Add Verification',
                'What should the screen show?',
                '',
                (desc) => {
                    if (!desc || desc.trim() === '') return;

                    // Use the "after" frame from current step, or "action" frame if no after
                    const frameToUse = step.frames?.after || step.frames?.action || null;

                    const newStep = {
                        id: 'verify_' + Date.now() + '_' + (++stepIdCounter),
                        action: 'verify_screen',
                        description: desc.trim(),
                        timestamp: step.timestamp + 0.1,
                        frames: frameToUse ? { action: frameToUse } : {}
                    };

                    // Insert right after the current step
                    steps.splice(stepIndex + 1, 0, newStep);
                    renderSteps();

                    // Scroll to the new step
                    setTimeout(() => {
                        const stepEl = document.querySelector(`[data-id="${newStep.id}"]`);
                        if (stepEl) stepEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }, 100);
                }
            );
        }

        function addWaitForAfterStep(stepId) {
            const stepIndex = steps.findIndex(s => s.id === stepId);
            if (stepIndex === -1) return;

            const step = steps[stepIndex];

            showMd3Dialog(
                'Add Wait For Element',
                'What element should appear?',
                '',
                (element) => {
                    if (!element || element.trim() === '') return;

                    const frameToUse = step.frames?.after || step.frames?.action || null;

                    const newStep = {
                        id: 'wait_for_' + Date.now() + '_' + (++stepIdCounter),
                        action: 'wait_for',
                        target: { text: element.trim() },
                        timestamp: step.timestamp + 0.1,
                        frames: frameToUse ? { action: frameToUse } : {}
                    };

                    steps.splice(stepIndex + 1, 0, newStep);
                    renderSteps();

                    setTimeout(() => {
                        const stepEl = document.querySelector(`[data-id="${newStep.id}"]`);
                        if (stepEl) stepEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }, 100);
                }
            );
        }

        function addWaitAfterStep(stepId) {
            const stepIndex = steps.findIndex(s => s.id === stepId);
            if (stepIndex === -1) return;

            const step = steps[stepIndex];

            showMd3Dialog(
                'Add Wait',
                'Duration (e.g., 2s, 500ms)',
                '2s',
                (duration) => {
                    if (!duration || duration.trim() === '') return;

                    const frameToUse = step.frames?.after || step.frames?.action || null;

                    const newStep = {
                        id: 'wait_' + Date.now() + '_' + (++stepIdCounter),
                        action: 'wait',
                        duration: duration.trim(),
                        timestamp: step.timestamp + 0.1,
                        frames: frameToUse ? { action: frameToUse } : {}
                    };

                    steps.splice(stepIndex + 1, 0, newStep);
                    renderSteps();

                    setTimeout(() => {
                        const stepEl = document.querySelector(`[data-id="${newStep.id}"]`);
                        if (stepEl) stepEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }, 100);
                }
            );
        }

        // Close Add Step Mode on ESC key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                if (document.getElementById('addStepMode').classList.contains('active')) {
                    discardAddStep();
                }
            }
        });

        // === ADD STEP MODE ===
        let addStepState = {
            type: null,           // 'tap', 'swipe', 'wait_for', 'type'
            position: null,       // {x, y} for tap/swipe
            direction: null,      // 'up', 'down', 'left', 'right' for swipe
            insertAfter: 'start',
            mainVideoTime: 0,     // Video time when Add Step was opened
            // Frame captures for 3-column layout
            frames: {
                before: null,     // Base64 data URL
                action: null,     // Base64 data URL (for tap/swipe)
                after: null       // Base64 data URL
            },
            tapPosition: null,    // {x, y, xPct, yPct} for tap indicator on action frame
            conditionEnabled: false,
            verificationEnabled: false
        };

        function openAddStepMode() {
            // Reset state
            addStepState = {
                type: null,
                position: null,
                direction: null,
                insertAfter: 'start',
                frames: { before: null, action: null, after: null },
                tapPosition: null,
                conditionEnabled: false,
                verificationEnabled: false
            };

            // Populate insert after dropdown
            const select = document.getElementById('addStepInsertAfter');
            select.innerHTML = '<option value="start">At the beginning</option>';
            steps.forEach((step, index) => {
                const label = step.analysis?.action || (step.action + ' ' + (step.target?.text || `at ${step.target?.x}, ${step.target?.y}` || ''));
                select.innerHTML += `<option value="${step.id}">${index + 1}. ${label.substring(0, 35)}${label.length > 35 ? '...' : ''}</option>`;
            });

            // Default to last step
            if (steps.length > 0) {
                select.value = steps[steps.length - 1].id;
                addStepState.insertAfter = steps[steps.length - 1].id;
            }

            // Add change listener
            select.onchange = () => {
                addStepState.insertAfter = select.value;
            };

            // Reset UI
            resetAddStepUI();

            // Store main video time for frame picker to use
            addStepState.mainVideoTime = document.getElementById('video').currentTime;

            // Show add step mode
            document.getElementById('addStepMode').classList.add('active');
        }

        function resetAddStepUI() {
            // Clear type selection
            document.querySelectorAll('.add-step-type-btn').forEach(btn => btn.classList.remove('selected'));

            // Hide the 3-column layout until type is selected
            document.getElementById('addStepColumns').style.display = 'none';

            // Reset frame previews
            ['Before', 'Action', 'After'].forEach(frameType => {
                const preview = document.getElementById(`addStep${frameType}Preview`);
                if (preview) {
                    preview.classList.remove('captured');
                    preview.innerHTML = `<span class="capture-hint">Click to capture frame</span>`;
                    if (frameType === 'Action') {
                        preview.innerHTML += '<div class="add-step-tap-indicator" id="addStepTapIndicator" style="display: none;"></div>';
                    }
                }
            });

            // Clear description inputs
            const beforeDesc = document.getElementById('addStepBeforeDesc');
            const afterDesc = document.getElementById('addStepAfterDesc');
            if (beforeDesc) beforeDesc.value = '';
            if (afterDesc) afterDesc.value = '';

            // Hide all action-specific controls
            ['Tap', 'Swipe', 'WaitFor', 'Type'].forEach(name => {
                const el = document.getElementById(`addStep${name}Controls`);
                if (el) el.style.display = 'none';
            });

            // Reset action column controls
            const tapPosition = document.getElementById('addStepTapPosition');
            if (tapPosition) tapPosition.textContent = 'Click on frame';
            const swipeStart = document.getElementById('addStepSwipeStart');
            if (swipeStart) swipeStart.textContent = 'Click on frame';

            // Clear direction selection
            document.querySelectorAll('.dir-btn').forEach(btn => btn.classList.remove('selected'));

            // Clear text inputs
            const waitForInput = document.getElementById('addStepWaitForInput');
            const typeInput = document.getElementById('addStepTypeInput');
            if (waitForInput) waitForInput.value = '';
            if (typeInput) typeInput.value = '';

            // Reset condition section
            const conditionBtn = document.getElementById('addStepConditionBtn');
            const conditionFields = document.getElementById('addStepConditionFields');
            const conditionValue = document.getElementById('addStepConditionValue');
            if (conditionBtn) conditionBtn.classList.remove('active');
            if (conditionFields) conditionFields.style.display = 'none';
            if (conditionValue) conditionValue.value = '';
            addStepState.conditionEnabled = false;

            // Reset verification section
            const verificationBtn = document.getElementById('addStepVerificationBtn');
            const verificationFields = document.getElementById('addStepVerificationFields');
            const verificationValue = document.getElementById('addStepVerificationValue');
            if (verificationBtn) verificationBtn.classList.remove('active');
            if (verificationFields) verificationFields.style.display = 'none';
            if (verificationValue) verificationValue.value = '';
            addStepState.verificationEnabled = false;

            // Clear indicators from video overlay
            const overlay = document.getElementById('addStepVideoOverlay');
            if (overlay) {
                overlay.innerHTML = '';
                overlay.classList.add('inactive');
            }

            // Reset instruction
            document.getElementById('addStepInstruction').textContent = 'Select a step type, then use the columns below to configure frames';
            document.getElementById('addStepInstruction').classList.remove('highlight');

            // Disable accept button
            document.getElementById('addStepAcceptBtn').disabled = true;

            // Reset state
            addStepState.frames = { before: null, action: null, after: null };
            addStepState.tapPosition = null;
            addStepState.direction = null;
        }

        function discardAddStep() {
            document.getElementById('addStepMode').classList.remove('active');
            // Pause video when closing
            document.getElementById('addStepVideo').pause();
        }

        // Video controls
        function initAddStepVideoControls() {
            const video = document.getElementById('addStepVideo');
            const scrubber = document.getElementById('addStepScrubber');
            const timeDisplay = document.getElementById('addStepTime');
            const playBtn = document.getElementById('addStepPlayBtn');

            // Update scrubber max when video loads
            video.addEventListener('loadedmetadata', () => {
                scrubber.max = video.duration;
                updateAddStepTime();
            });

            // Update scrubber and time during playback
            video.addEventListener('timeupdate', () => {
                scrubber.value = video.currentTime;
                updateAddStepTime();
            });

            // Update play button state
            video.addEventListener('play', () => {
                playBtn.textContent = '⏸';
            });

            video.addEventListener('pause', () => {
                playBtn.textContent = '▶';
            });

            // Scrubber input
            scrubber.addEventListener('input', () => {
                video.currentTime = scrubber.value;
                updateAddStepTime();
            });
        }

        function toggleAddStepVideo() {
            const video = document.getElementById('addStepVideo');
            if (video.paused) {
                video.play();
            } else {
                video.pause();
            }
        }

        function updateAddStepTime() {
            const video = document.getElementById('addStepVideo');
            const timeDisplay = document.getElementById('addStepTime');

            const formatTime = (seconds) => {
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            };

            const current = formatTime(video.currentTime || 0);
            const duration = formatTime(video.duration || 0);
            timeDisplay.textContent = `${current} / ${duration}`;
        }

        function selectAddStepType(type) {
            addStepState.type = type;
            addStepState.position = null;
            addStepState.direction = null;
            addStepState.tapPosition = null;

            // Update button selection
            document.querySelectorAll('.add-step-type-btn').forEach(btn => {
                btn.classList.toggle('selected', btn.dataset.type === type);
            });

            // Show 3-column layout
            document.getElementById('addStepColumns').style.display = 'flex';

            // Show/hide Action column based on step type
            const actionColumn = document.getElementById('addStepActionColumn');
            if (type === 'tap' || type === 'swipe') {
                actionColumn.style.display = '';
            } else {
                actionColumn.style.display = 'none';
            }

            // Hide all action-specific controls first
            ['Tap', 'Swipe', 'WaitFor', 'Type'].forEach(name => {
                const el = document.getElementById(`addStep${name}Controls`);
                if (el) el.style.display = 'none';
            });

            // Show appropriate controls in action column
            if (type === 'tap') {
                document.getElementById('addStepTapControls').style.display = '';
                document.getElementById('addStepInstruction').textContent = 'Capture frames and click on Action frame to place tap';
                document.getElementById('addStepInstruction').classList.add('highlight');
            } else if (type === 'swipe') {
                document.getElementById('addStepSwipeControls').style.display = '';
                document.getElementById('addStepInstruction').textContent = 'Capture frames, click on Action frame to set start, then choose direction';
                document.getElementById('addStepInstruction').classList.add('highlight');
            } else if (type === 'wait_for') {
                document.getElementById('addStepWaitForControls').style.display = '';
                document.getElementById('addStepInstruction').textContent = 'Enter element text to wait for and optionally capture frames';
                document.getElementById('addStepInstruction').classList.remove('highlight');
                document.getElementById('addStepWaitForInput').focus();
            } else if (type === 'type') {
                document.getElementById('addStepTypeControls').style.display = '';
                document.getElementById('addStepInstruction').textContent = 'Enter text to type and optionally capture frames';
                document.getElementById('addStepInstruction').classList.remove('highlight');
                document.getElementById('addStepTypeInput').focus();
            }

            updateAddStepReady();
        }

        // Toggle condition in Add Step (button-based, not checkbox)
        function toggleAddStepCondition() {
            addStepState.conditionEnabled = !addStepState.conditionEnabled;
            const btn = document.getElementById('addStepConditionBtn');
            const fields = document.getElementById('addStepConditionFields');

            btn.classList.toggle('active', addStepState.conditionEnabled);
            fields.style.display = addStepState.conditionEnabled ? '' : 'none';

            if (addStepState.conditionEnabled) {
                btn.textContent = '- Condition';
                document.getElementById('addStepConditionValue').focus();
            } else {
                btn.textContent = '+ Condition';
            }
        }

        // Toggle verification in Add Step (button-based, not checkbox)
        function toggleAddStepVerification() {
            addStepState.verificationEnabled = !addStepState.verificationEnabled;
            const btn = document.getElementById('addStepVerificationBtn');
            const fields = document.getElementById('addStepVerificationFields');

            btn.classList.toggle('active', addStepState.verificationEnabled);
            fields.style.display = addStepState.verificationEnabled ? '' : 'none';

            if (addStepState.verificationEnabled) {
                btn.textContent = '- Verification';
                document.getElementById('addStepVerificationValue').focus();
            } else {
                btn.textContent = '+ Verification';
            }
        }

        function getVideoContentRect(video) {
            // Get the actual video content area within the video element
            // accounting for letterboxing (black bars)
            const rect = video.getBoundingClientRect();
            const videoAspect = video.videoWidth / video.videoHeight;
            const elementAspect = rect.width / rect.height;

            let contentWidth, contentHeight, offsetX, offsetY;

            if (videoAspect > elementAspect) {
                // Video is wider than element - bars on top/bottom
                contentWidth = rect.width;
                contentHeight = rect.width / videoAspect;
                offsetX = 0;
                offsetY = (rect.height - contentHeight) / 2;
            } else {
                // Video is taller than element - bars on left/right
                contentHeight = rect.height;
                contentWidth = rect.height * videoAspect;
                offsetX = (rect.width - contentWidth) / 2;
                offsetY = 0;
            }

            return {
                left: rect.left + offsetX,
                top: rect.top + offsetY,
                width: contentWidth,
                height: contentHeight,
                offsetX,
                offsetY
            };
        }

        // Video overlay click is disabled - use frame captures in columns instead
        function handleAddStepVideoClick(event) {
            // No-op: tap/swipe position is set via the action frame preview in 3-column layout
        }

        function resetAddStepPosition() {
            // Clear tap position in state
            addStepState.tapPosition = null;
            addStepState.direction = null;

            // Clear direction button selection
            document.querySelectorAll('.dir-btn').forEach(btn => btn.classList.remove('selected'));

            // Reset tap indicator
            const indicator = document.getElementById('addStepTapIndicator');
            if (indicator) indicator.style.display = 'none';

            // Reset position displays
            const tapPos = document.getElementById('addStepTapPosition');
            if (tapPos) tapPos.textContent = 'Click on frame';
            const swipeStart = document.getElementById('addStepSwipeStart');
            if (swipeStart) swipeStart.textContent = 'Click on frame';

            // Update instruction based on type
            if (addStepState.type === 'tap') {
                document.getElementById('addStepInstruction').textContent = 'Capture frames and click on Action frame to place tap';
            } else if (addStepState.type === 'swipe') {
                document.getElementById('addStepInstruction').textContent = 'Click on the video to set swipe start position';
            }

            // Disable accept button
            document.getElementById('addStepAcceptBtn').disabled = true;
        }

        function updateAddStepReady() {
            const type = addStepState.type;
            let ready = false;

            if (type === 'tap') {
                // Need tap position
                ready = addStepState.tapPosition !== null;
            } else if (type === 'swipe') {
                // Need position and direction
                ready = addStepState.tapPosition !== null && addStepState.direction !== null;
            } else if (type === 'wait_for') {
                ready = document.getElementById('addStepWaitForInput').value.trim() !== '';
            } else if (type === 'type') {
                ready = document.getElementById('addStepTypeInput').value.trim() !== '';
            }

            document.getElementById('addStepAcceptBtn').disabled = !ready;
        }

        // Capture frame from video and store in state
        function captureAddStepFrame(frameType) {
            const video = document.getElementById('addStepVideo');
            if (!video || video.videoWidth === 0 || video.videoHeight === 0) {
                return;
            }

            try {
                const canvas = document.createElement('canvas');
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                const dataUrl = canvas.toDataURL('image/png');

                // Store in state
                addStepState.frames[frameType] = dataUrl;

                // Update preview
                const previewId = `addStep${frameType.charAt(0).toUpperCase() + frameType.slice(1)}Preview`;
                const preview = document.getElementById(previewId);
                if (preview) {
                    preview.classList.add('captured');
                    // Create img element while preserving tap indicator for action frame
                    const existingIndicator = preview.querySelector('.add-step-tap-indicator');
                    preview.innerHTML = `<img src="${dataUrl}" alt="${frameType} frame">`;
                    if (frameType === 'action' && existingIndicator) {
                        preview.appendChild(existingIndicator);
                    } else if (frameType === 'action') {
                        const indicator = document.createElement('div');
                        indicator.className = 'add-step-tap-indicator';
                        indicator.id = 'addStepTapIndicator';
                        indicator.style.display = 'none';
                        preview.appendChild(indicator);
                    }
                }
            } catch (e) {
                console.error('Failed to capture frame:', e);
            }
        }

        // Handle click on action frame preview - capture first, then allow tap placement
        function handleActionPreviewClick(event) {
            // If no frame captured yet, capture it
            if (!addStepState.frames.action) {
                captureAddStepFrame('action');
                return;
            }
            // If frame is captured, handle tap placement
            handleActionFrameClick(event);
        }

        // Handle click on action frame preview to place tap/swipe position
        function handleActionFrameClick(event) {
            if (!addStepState.type || (addStepState.type !== 'tap' && addStepState.type !== 'swipe')) return;
            if (!addStepState.frames.action) return; // Must have captured action frame first

            const preview = document.getElementById('addStepActionPreview');
            const img = preview.querySelector('img');
            if (!img) return;

            const rect = img.getBoundingClientRect();
            const clickX = event.clientX - rect.left;
            const clickY = event.clientY - rect.top;

            // Calculate percentage coordinates
            const xPct = (clickX / rect.width) * 100;
            const yPct = (clickY / rect.height) * 100;

            // Clamp to valid range
            const xPctClamped = Math.max(0, Math.min(100, xPct));
            const yPctClamped = Math.max(0, Math.min(100, yPct));

            // Convert to screen coordinates
            const x = Math.round((xPctClamped / 100) * SCREEN_WIDTH);
            const y = Math.round((yPctClamped / 100) * SCREEN_HEIGHT);

            addStepState.tapPosition = { x, y, xPct: xPctClamped, yPct: yPctClamped };

            // Show indicator on action frame
            const indicator = document.getElementById('addStepTapIndicator');
            if (indicator) {
                indicator.style.display = '';
                indicator.style.left = xPctClamped + '%';
                indicator.style.top = yPctClamped + '%';
            }

            // Update position display
            if (addStepState.type === 'tap') {
                document.getElementById('addStepTapPosition').textContent = `(${x}, ${y})`;
            } else if (addStepState.type === 'swipe') {
                document.getElementById('addStepSwipeStart').textContent = `(${x}, ${y})`;
            }

            updateAddStepReady();
        }

        // Direction selection for swipe
        function selectAddStepDirection(direction) {
            addStepState.direction = direction;
            document.querySelectorAll('.dir-btn').forEach(btn => {
                btn.classList.toggle('selected', btn.dataset.dir === direction);
            });
            updateAddStepReady();
        }

        function acceptAddStep() {
            const type = addStepState.type;
            const insertAfter = addStepState.insertAfter;
            let stepData = null;

            const timestamp = document.getElementById('addStepVideo').currentTime;

            if (type === 'tap' && addStepState.tapPosition) {
                stepData = {
                    action: 'tap',
                    target: { x: addStepState.tapPosition.x, y: addStepState.tapPosition.y }
                };
            } else if (type === 'swipe' && addStepState.tapPosition && addStepState.direction) {
                stepData = {
                    action: 'swipe',
                    target: { x: addStepState.tapPosition.x, y: addStepState.tapPosition.y },
                    direction: addStepState.direction
                };
            } else if (type === 'wait_for') {
                const element = document.getElementById('addStepWaitForInput').value.trim();
                if (!element) return;
                stepData = {
                    action: 'wait_for',
                    target: { text: element }
                };
            } else if (type === 'type') {
                const text = document.getElementById('addStepTypeInput').value.trim();
                if (!text) return;
                stepData = {
                    action: 'type',
                    text: text
                };
            }

            if (!stepData) return;

            // Collect frames from state
            const frames = {};
            if (addStepState.frames.before) frames.before = addStepState.frames.before;
            if (addStepState.frames.action) frames.action = addStepState.frames.action;
            if (addStepState.frames.after) frames.after = addStepState.frames.after;

            // Collect descriptions
            const beforeDesc = document.getElementById('addStepBeforeDesc')?.value.trim();
            const afterDesc = document.getElementById('addStepAfterDesc')?.value.trim();

            // Add optional condition if enabled
            let conditions = [];
            if (addStepState.conditionEnabled) {
                const condType = document.getElementById('addStepConditionType').value;
                const condValue = document.getElementById('addStepConditionValue').value.trim();
                if (condValue) {
                    conditions.push({ type: condType, value: condValue });
                }
            }

            // Add optional verification if enabled
            let verifications = [];
            if (addStepState.verificationEnabled) {
                const verValue = document.getElementById('addStepVerificationValue').value.trim();
                if (verValue) {
                    verifications.push({ description: verValue });
                }
            }

            // Build analysis with descriptions
            const analysis = {};
            if (beforeDesc) analysis.before = beforeDesc;
            if (afterDesc) analysis.after = afterDesc;

            const newStep = {
                id: stepData.action + '_' + Date.now() + '_' + (++stepIdCounter),
                ...stepData,
                timestamp: timestamp,
                frames: Object.keys(frames).length > 0 ? frames : undefined,
                analysis: Object.keys(analysis).length > 0 ? analysis : undefined,
                conditions: conditions.length > 0 ? conditions : undefined,
                verifications: verifications.length > 0 ? verifications : undefined
            };

            // Insert at the right position
            if (insertAfter === 'start') {
                steps.unshift(newStep);
            } else {
                const stepIndex = steps.findIndex(s => s.id === insertAfter);
                if (stepIndex !== -1) {
                    steps.splice(stepIndex + 1, 0, newStep);
                } else {
                    steps.push(newStep);
                }
            }

            // Close add step mode
            document.getElementById('addStepMode').classList.remove('active');

            // Render steps and scroll to new step
            renderSteps();
            setTimeout(() => {
                const stepEl = document.querySelector(`[data-id="${newStep.id}"]`);
                if (stepEl) stepEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }, 100);
        }

        // === FRAME PICKER MODAL (Video Scrubber Approach) ===
        let framePickerState = {
            frameType: null,      // 'before', 'action', 'after'
            tapPosition: null,    // {x, y, xPct, yPct} for tap actions
            swipeStart: null,     // {x, y, xPct, yPct} for swipe start
            swipeEnd: null,       // {x, y, xPct, yPct} for swipe end
            isPlaying: false,
            videoWidth: 0,
            videoHeight: 0,
            fps: 30,             // Assumed frame rate for frame stepping
            editingStepId: null  // Track if editing an existing step (null = Add Step mode)
        };

        function openFramePickerModal(frameType) {
            framePickerState.frameType = frameType;
            framePickerState.tapPosition = null;
            framePickerState.swipeStart = null;
            framePickerState.swipeEnd = null;
            framePickerState.editingStepId = null; // Clear editing mode (Add Step mode)

            // Set modal title and subtitle
            const titles = {
                before: 'Select Before Frame',
                action: 'Select Action Frame',
                after: 'Select After Frame'
            };
            document.getElementById('framePickerTitle').textContent = titles[frameType] || 'Select Frame';

            // Configure overlay for tap placement (only for action frames with tap/swipe)
            const overlay = document.getElementById('framePickerOverlay');
            const positionInfo = document.getElementById('framePickerPositionInfo');
            const hint = document.getElementById('framePickerHint');
            const hintText = document.getElementById('framePickerHintText');
            const isActionFrame = frameType === 'action' && (addStepState.type === 'tap' || addStepState.type === 'swipe');

            if (isActionFrame) {
                overlay.classList.remove('inactive');
                hint.style.display = 'flex';
                const hintIcon = hint.querySelector('.material-symbols-outlined');
                if (addStepState.type === 'swipe') {
                    hintIcon.textContent = 'swipe';
                    hintText.textContent = 'Click START position, then click END position';
                } else {
                    hintIcon.textContent = 'touch_app';
                    hintText.textContent = 'Click on the video to set tap position';
                }
            } else {
                overlay.classList.add('inactive');
                hint.style.display = 'none';
            }
            positionInfo.style.display = 'none';

            // Clear any existing indicators
            document.getElementById('framePickerTapIndicator').style.display = 'none';
            document.getElementById('framePickerSwipeStart').style.display = 'none';
            document.getElementById('framePickerSwipeEnd').style.display = 'none';
            document.getElementById('framePickerSwipeLine').style.display = 'none';

            // Show modal
            document.getElementById('framePickerModal').classList.add('active');

            // Initialize video player
            initFramePickerVideo();
        }

        function closeFramePickerModal() {
            const video = document.getElementById('framePickerVideo');
            if (video) {
                video.pause();
                framePickerState.isPlaying = false;
            }
            document.getElementById('framePickerModal').classList.remove('active');
        }

        // Open Frame Picker to edit an existing step's frame
        function openFramePickerForStep(stepId, frameType) {
            const step = steps.find(s => s.id === stepId);
            if (!step) {
                console.error('Step not found:', stepId);
                return;
            }

            framePickerState.frameType = frameType;
            framePickerState.tapPosition = null;
            framePickerState.swipeStart = null;
            framePickerState.swipeEnd = null;
            framePickerState.editingStepId = stepId; // Set editing mode

            // Set modal title and subtitle for editing
            const titles = {
                before: 'Edit Before Frame',
                action: 'Edit Action Frame',
                after: 'Edit After Frame'
            };
            document.getElementById('framePickerTitle').textContent = titles[frameType] || 'Edit Frame';

            // Configure overlay for tap placement (only for action frames with tap/swipe)
            const overlay = document.getElementById('framePickerOverlay');
            const positionInfo = document.getElementById('framePickerPositionInfo');
            const hint = document.getElementById('framePickerHint');
            const hintText = document.getElementById('framePickerHintText');
            const isActionFrame = frameType === 'action' && (step.action === 'tap' || step.action === 'swipe');

            if (isActionFrame) {
                overlay.classList.remove('inactive');
                hint.style.display = 'flex';
                const hintIcon = hint.querySelector('.material-symbols-outlined');
                if (step.action === 'swipe') {
                    hintIcon.textContent = 'swipe';
                    hintText.textContent = 'Click START position, then click END position';
                } else {
                    hintIcon.textContent = 'touch_app';
                    hintText.textContent = 'Click on the video to set tap position';
                }
            } else {
                overlay.classList.add('inactive');
                hint.style.display = 'none';
            }
            positionInfo.style.display = 'none';

            // Clear any existing indicators
            document.getElementById('framePickerTapIndicator').style.display = 'none';
            document.getElementById('framePickerSwipeStart').style.display = 'none';
            document.getElementById('framePickerSwipeEnd').style.display = 'none';
            document.getElementById('framePickerSwipeLine').style.display = 'none';

            // Show modal
            document.getElementById('framePickerModal').classList.add('active');

            // Initialize video player and seek to step timestamp
            initFramePickerVideo();

            // Seek to step's timestamp after video is ready
            const video = document.getElementById('framePickerVideo');
            if (video && step.timestamp) {
                const seekToTimestamp = () => {
                    video.currentTime = step.timestamp;
                    video.removeEventListener('loadedmetadata', seekToTimestamp);
                };
                if (video.readyState >= 1) {
                    video.currentTime = step.timestamp;
                } else {
                    video.addEventListener('loadedmetadata', seekToTimestamp);
                }
            }
        }

        function initFramePickerVideo() {
            const video = document.getElementById('framePickerVideo');

            function onVideoReady() {
                framePickerState.videoWidth = video.videoWidth;
                framePickerState.videoHeight = video.videoHeight;

                // Update duration display
                document.getElementById('durationDisplay').textContent = formatTime(video.duration);
                document.getElementById('currentTimeDisplay').textContent = formatTime(video.currentTime);

                // Calculate frame number
                updateFrameNumber();

                // Start paused at beginning
                video.currentTime = 0;
                video.pause();
                framePickerState.isPlaying = false;
                updatePlayButton();

                // Generate scrubber markers (sparse thumbnails)
                generateScrubberMarkers();
            }

            // Set up video event listeners
            video.removeEventListener('timeupdate', onVideoTimeUpdate);
            video.addEventListener('timeupdate', onVideoTimeUpdate);

            video.removeEventListener('loadedmetadata', onVideoReady);

            if (video.readyState >= 1 && video.duration > 0) {
                onVideoReady();
            } else {
                video.addEventListener('loadedmetadata', onVideoReady);
                video.load();
            }
        }

        function onVideoTimeUpdate() {
            const video = document.getElementById('framePickerVideo');
            if (!video) return;

            // Update time display
            document.getElementById('currentTimeDisplay').textContent = formatTime(video.currentTime);

            // Update scrubber position
            const progress = video.currentTime / video.duration;
            document.getElementById('scrubberProgress').style.width = (progress * 100) + '%';
            document.getElementById('scrubberThumb').style.left = (progress * 100) + '%';

            // Update frame number
            updateFrameNumber();
        }

        function updateFrameNumber() {
            const video = document.getElementById('framePickerVideo');
            if (!video) return;
            const frameNum = Math.round(video.currentTime * framePickerState.fps);
            document.getElementById('frameNumberDisplay').textContent = frameNum;
        }

        function updatePlayButton() {
            const icon = document.getElementById('fpPlayIcon');
            const indicator = document.getElementById('videoPlayIndicator');
            if (framePickerState.isPlaying) {
                icon.textContent = 'pause';
                indicator.querySelector('.material-symbols-outlined').textContent = 'play_arrow';
                indicator.classList.remove('show');
            } else {
                icon.textContent = 'play_arrow';
                indicator.querySelector('.material-symbols-outlined').textContent = 'pause';
                indicator.classList.add('show');
                setTimeout(() => indicator.classList.remove('show'), 500);
            }
        }

        function generateScrubberMarkers() {
            const video = document.getElementById('framePickerVideo');
            const markers = document.getElementById('scrubberMarkers');
            markers.innerHTML = '';

            if (!video.duration) return;

            // Generate 8 evenly spaced markers
            const markerCount = 8;
            for (let i = 0; i <= markerCount; i++) {
                const time = (i / markerCount) * video.duration;
                const pct = (i / markerCount) * 100;

                const marker = document.createElement('div');
                marker.className = 'scrubber-marker';
                marker.style.left = pct + '%';

                const timeLabel = document.createElement('span');
                timeLabel.className = 'marker-time';
                timeLabel.textContent = formatTime(time);
                marker.appendChild(timeLabel);

                markers.appendChild(marker);
            }
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        // Video control functions
        function toggleFramePickerPlay() {
            const video = document.getElementById('framePickerVideo');
            if (framePickerState.isPlaying) {
                video.pause();
                framePickerState.isPlaying = false;
            } else {
                video.play();
                framePickerState.isPlaying = true;
            }
            updatePlayButton();
        }

        function framePickerStepFrame(direction) {
            const video = document.getElementById('framePickerVideo');
            video.pause();
            framePickerState.isPlaying = false;
            updatePlayButton();

            // Step by approximately one frame (1/fps)
            const frameTime = 1 / framePickerState.fps;
            video.currentTime = Math.max(0, Math.min(video.duration, video.currentTime + (direction * frameTime)));
        }

        function framePickerSkip(seconds) {
            const video = document.getElementById('framePickerVideo');
            video.currentTime = Math.max(0, Math.min(video.duration, video.currentTime + seconds));
        }

        function framePickerSkipTo(time) {
            const video = document.getElementById('framePickerVideo');
            video.currentTime = time;
        }

        function framePickerSkipToEnd() {
            const video = document.getElementById('framePickerVideo');
            video.currentTime = video.duration - 0.1; // Slightly before end to avoid edge case
        }

        function handleScrubberClick(event) {
            const track = document.getElementById('scrubberTrack');
            const rect = track.getBoundingClientRect();
            const clickX = event.clientX - rect.left;
            const pct = Math.max(0, Math.min(1, clickX / rect.width));

            const video = document.getElementById('framePickerVideo');
            video.currentTime = pct * video.duration;

            // Pause when scrubbing
            video.pause();
            framePickerState.isPlaying = false;
            updatePlayButton();
        }

        function handleFramePickerVideoClick(event) {
            const video = document.getElementById('framePickerVideo');
            const overlay = document.getElementById('framePickerOverlay');

            // Pause video on click
            if (framePickerState.isPlaying) {
                video.pause();
                framePickerState.isPlaying = false;
                updatePlayButton();
            }

            // Handle tap position only for action frames with tap/swipe
            if (framePickerState.frameType !== 'action') return;

            // Check action type from either edit mode (existing step) or add mode
            let actionType = null;
            if (framePickerState.editingStepId) {
                const editingStep = steps.find(s => s.id === framePickerState.editingStepId);
                actionType = editingStep?.action;
            } else {
                actionType = addStepState.type;
            }

            if (!actionType || (actionType !== 'tap' && actionType !== 'swipe')) return;

            const rect = video.getBoundingClientRect();

            // Calculate click position relative to video
            const clickX = event.clientX - rect.left;
            const clickY = event.clientY - rect.top;

            // Check if click is within video
            if (clickX < 0 || clickX > rect.width || clickY < 0 || clickY > rect.height) {
                return;
            }

            // Calculate percentage coordinates
            const xPct = Math.max(0, Math.min(100, (clickX / rect.width) * 100));
            const yPct = Math.max(0, Math.min(100, (clickY / rect.height) * 100));

            // Convert to screen coordinates
            const x = Math.round((xPct / 100) * SCREEN_WIDTH);
            const y = Math.round((yPct / 100) * SCREEN_HEIGHT);

            if (actionType === 'tap') {
                // TAP: Single click sets position
                framePickerState.tapPosition = { x, y, xPct, yPct };

                // Show tap indicator
                const indicator = document.getElementById('framePickerTapIndicator');
                indicator.style.display = '';
                indicator.style.left = xPct + '%';
                indicator.style.top = yPct + '%';

                // Show position info
                document.getElementById('framePickerPositionInfo').style.display = 'flex';
                document.getElementById('framePickerPositionIcon').textContent = 'touch_app';
                document.getElementById('framePickerPositionLabel').textContent = 'TAP';
                document.getElementById('framePickerPositionValue').textContent = `(${xPct.toFixed(1)}%, ${yPct.toFixed(1)}%)`;

            } else if (actionType === 'swipe') {
                // SWIPE: First click = start, second click = end
                if (!framePickerState.swipeStart || framePickerState.swipeEnd) {
                    // Set start (or reset if both were already set)
                    framePickerState.swipeStart = { x, y, xPct, yPct };
                    framePickerState.swipeEnd = null;

                    // Show start indicator
                    const startIndicator = document.getElementById('framePickerSwipeStart');
                    startIndicator.style.display = '';
                    startIndicator.style.left = xPct + '%';
                    startIndicator.style.top = yPct + '%';

                    // Hide end indicator and line
                    document.getElementById('framePickerSwipeEnd').style.display = 'none';
                    document.getElementById('framePickerSwipeLine').style.display = 'none';

                    // Show position info with just start
                    document.getElementById('framePickerPositionInfo').style.display = 'flex';
                    document.getElementById('framePickerPositionIcon').textContent = 'swipe';
                    document.getElementById('framePickerPositionLabel').textContent = 'START';
                    document.getElementById('framePickerPositionValue').textContent = `(${xPct.toFixed(1)}%, ${yPct.toFixed(1)}%) → click end`;

                } else {
                    // Set end
                    framePickerState.swipeEnd = { x, y, xPct, yPct };

                    // Show end indicator
                    const endIndicator = document.getElementById('framePickerSwipeEnd');
                    endIndicator.style.display = '';
                    endIndicator.style.left = xPct + '%';
                    endIndicator.style.top = yPct + '%';

                    // Show line connecting start to end
                    updateSwipeLine();

                    // Update position info with both start and end
                    const start = framePickerState.swipeStart;
                    document.getElementById('framePickerPositionInfo').style.display = 'flex';
                    document.getElementById('framePickerPositionIcon').textContent = 'swipe';
                    document.getElementById('framePickerPositionLabel').textContent = 'SWIPE';
                    document.getElementById('framePickerPositionValue').textContent =
                        `(${start.xPct.toFixed(0)}%, ${start.yPct.toFixed(0)}%) → (${xPct.toFixed(0)}%, ${yPct.toFixed(0)}%)`;
                }
            }
        }

        function updateSwipeLine() {
            const start = framePickerState.swipeStart;
            const end = framePickerState.swipeEnd;
            if (!start || !end) return;

            const svg = document.getElementById('framePickerSwipeLine');
            const line = document.getElementById('swipeLineElement');

            svg.style.display = '';
            line.setAttribute('x1', start.xPct + '%');
            line.setAttribute('y1', start.yPct + '%');
            line.setAttribute('x2', end.xPct + '%');
            line.setAttribute('y2', end.yPct + '%');
        }

        function clearFramePickerPosition() {
            // Clear tap
            framePickerState.tapPosition = null;
            document.getElementById('framePickerTapIndicator').style.display = 'none';

            // Clear swipe
            framePickerState.swipeStart = null;
            framePickerState.swipeEnd = null;
            document.getElementById('framePickerSwipeStart').style.display = 'none';
            document.getElementById('framePickerSwipeEnd').style.display = 'none';
            document.getElementById('framePickerSwipeLine').style.display = 'none';

            // Hide position info
            document.getElementById('framePickerPositionInfo').style.display = 'none';
        }

        function captureFromFramePicker() {
            const video = document.getElementById('framePickerVideo');

            // Capture current frame from video
            if (!video || video.videoWidth === 0 || video.videoHeight === 0) {
                console.error('Video not ready for capture');
                return;
            }

            try {
                const canvas = document.createElement('canvas');
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(video, 0, 0);
                const dataUrl = canvas.toDataURL('image/jpeg', 0.9);

                const frameType = framePickerState.frameType;

                // Check if editing an existing step or adding a new one
                if (framePickerState.editingStepId) {
                    // EDIT MODE: Update existing step's frame
                    const step = steps.find(s => s.id === framePickerState.editingStepId);
                    if (step) {
                        // Initialize frames object if it doesn't exist
                        if (!step.frames) {
                            step.frames = {};
                        }
                        step.frames[frameType] = dataUrl;

                        // Update position for action frames
                        if (frameType === 'action') {
                            step.target = step.target || {};

                            if (step.action === 'tap' && framePickerState.tapPosition) {
                                // TAP: single position
                                step.target.x = Math.round((framePickerState.tapPosition.xPct / 100) * SCREEN_WIDTH);
                                step.target.y = Math.round((framePickerState.tapPosition.yPct / 100) * SCREEN_HEIGHT);

                            } else if (step.action === 'swipe' && framePickerState.swipeStart && framePickerState.swipeEnd) {
                                // SWIPE: start and end positions
                                step.target.x = Math.round((framePickerState.swipeStart.xPct / 100) * SCREEN_WIDTH);
                                step.target.y = Math.round((framePickerState.swipeStart.yPct / 100) * SCREEN_HEIGHT);
                                step.target.endX = Math.round((framePickerState.swipeEnd.xPct / 100) * SCREEN_WIDTH);
                                step.target.endY = Math.round((framePickerState.swipeEnd.yPct / 100) * SCREEN_HEIGHT);
                            }
                        }

                        // Re-render to update the UI
                        renderSteps();

                        // Re-highlight the step being edited
                        setTimeout(() => {
                            setActiveStep(framePickerState.editingStepId);
                        }, 50);
                    }
                } else {
                    // ADD STEP MODE: Store in addStepState
                    addStepState.frames[frameType] = dataUrl;

                    // Update preview in Add Step
                    const previewId = `addStep${frameType.charAt(0).toUpperCase() + frameType.slice(1)}Preview`;
                    const preview = document.getElementById(previewId);
                    if (preview) {
                        preview.classList.add('captured');
                        preview.innerHTML = `<img src="${dataUrl}" alt="${frameType} frame">`;

                        // For action frame, add position indicators
                        if (frameType === 'action') {
                            if (addStepState.type === 'tap' && framePickerState.tapPosition) {
                                // TAP: single indicator
                                addStepState.tapPosition = framePickerState.tapPosition;

                                const indicator = document.createElement('div');
                                indicator.className = 'add-step-tap-indicator';
                                indicator.id = 'addStepTapIndicator';
                                indicator.style.left = framePickerState.tapPosition.xPct + '%';
                                indicator.style.top = framePickerState.tapPosition.yPct + '%';
                                preview.appendChild(indicator);

                                // Update position display
                                const pctDisplay = `(${framePickerState.tapPosition.xPct.toFixed(1)}%, ${framePickerState.tapPosition.yPct.toFixed(1)}%)`;
                                document.getElementById('addStepTapPosition').textContent = pctDisplay;

                            } else if (addStepState.type === 'swipe' && framePickerState.swipeStart && framePickerState.swipeEnd) {
                                // SWIPE: start + end indicators with line
                                addStepState.swipeStart = framePickerState.swipeStart;
                                addStepState.swipeEnd = framePickerState.swipeEnd;

                                // Add SVG line
                                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                                svg.style.cssText = 'position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;';
                                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                                line.setAttribute('x1', framePickerState.swipeStart.xPct + '%');
                                line.setAttribute('y1', framePickerState.swipeStart.yPct + '%');
                                line.setAttribute('x2', framePickerState.swipeEnd.xPct + '%');
                                line.setAttribute('y2', framePickerState.swipeEnd.yPct + '%');
                                line.setAttribute('stroke', 'var(--md-tertiary)');
                                line.setAttribute('stroke-width', '2');
                                line.setAttribute('stroke-dasharray', '4,2');
                                svg.appendChild(line);
                                preview.appendChild(svg);

                                // Add start indicator
                                const startIndicator = document.createElement('div');
                                startIndicator.className = 'add-step-swipe-indicator start';
                                startIndicator.style.left = framePickerState.swipeStart.xPct + '%';
                                startIndicator.style.top = framePickerState.swipeStart.yPct + '%';
                                preview.appendChild(startIndicator);

                                // Add end indicator
                                const endIndicator = document.createElement('div');
                                endIndicator.className = 'add-step-swipe-indicator end';
                                endIndicator.style.left = framePickerState.swipeEnd.xPct + '%';
                                endIndicator.style.top = framePickerState.swipeEnd.yPct + '%';
                                preview.appendChild(endIndicator);

                                // Update position display
                                const startDisplay = `(${framePickerState.swipeStart.xPct.toFixed(0)}%, ${framePickerState.swipeStart.yPct.toFixed(0)}%)`;
                                const endDisplay = `(${framePickerState.swipeEnd.xPct.toFixed(0)}%, ${framePickerState.swipeEnd.yPct.toFixed(0)}%)`;
                                document.getElementById('addStepSwipeStart').textContent = startDisplay + ' → ' + endDisplay;
                            }
                        }
                    }

                    // Update ready state
                    updateAddStepReady();
                }

                // Close modal
                closeFramePickerModal();
            } catch (e) {
                console.error('Failed to capture frame:', e);
            }
        }

        function captureVideoFrame() {
            const video = document.getElementById('video');

            // Check if video is loaded
            if (!video || video.videoWidth === 0 || video.videoHeight === 0) {
                console.warn('Video not loaded, cannot capture frame');
                return null;
            }

            try {
                const canvas = document.createElement('canvas');
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                return canvas.toDataURL('image/png');
            } catch (e) {
                console.error('Failed to capture video frame:', e);
                return null;
            }
        }

        function addStep(type) {
            const video = document.getElementById('video');
            const timestamp = video.currentTime;

            // Capture frame at current position
            const frameDataUrl = captureVideoFrame();

            let newStep;
            if (type === 'verify_screen') {
                const desc = prompt('What should the screen show?');
                if (!desc) return;
                newStep = {
                    id: 'verify_' + Date.now() + '_' + (++stepIdCounter),
                    action: 'verify_screen',
                    description: desc,
                    timestamp,
                    frames: { action: frameDataUrl }
                };
            } else if (type === 'wait_for') {
                const element = prompt('What element to wait for?');
                if (!element) return;
                newStep = {
                    id: 'wait_for_' + Date.now() + '_' + (++stepIdCounter),
                    action: 'wait_for',
                    target: { text: element },
                    timeout: 10,
                    timestamp,
                    frames: { action: frameDataUrl }
                };
            } else if (type === 'wait') {
                const duration = prompt('Wait duration in seconds:', '2');
                if (!duration) return;
                newStep = {
                    id: 'wait_' + Date.now() + '_' + (++stepIdCounter),
                    action: 'wait',
                    duration: parseFloat(duration),
                    timestamp,
                    frames: { action: frameDataUrl }
                };
            }

            // Insert at correct position based on timestamp
            const insertIndex = steps.findIndex(s => s.timestamp > timestamp);
            if (insertIndex === -1) {
                steps.push(newStep);
            } else {
                steps.splice(insertIndex, 0, newStep);
            }
            renderSteps();

            // Scroll to the new step
            setTimeout(() => {
                const stepEl = document.querySelector(`[data-id="${newStep.id}"]`);
                if (stepEl) stepEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }, 100);
        }

        // Export Functions
        function exportYAML() {
            const yaml = generateYAML();
            downloadFile(testData.testName + '.yaml', yaml);
        }

        function generateYAML() {
            let yaml = `config:\n  app: ${testData.appPackage}\n\ntests:\n  - name: ${testData.testName}\n    steps:\n`;

            for (const step of steps) {
                yaml += stepToYAML(step);
            }

            return yaml;
        }

        function stepToYAML(step, indent = '      ') {
            let yaml = '';

            // Handle new conditions array format (Step Model Redesign v2)
            if (step.conditions && step.conditions.length > 0) {
                // Wrap action in nested conditions
                let currentIndent = indent;
                for (const cond of step.conditions) {
                    yaml += `${currentIndent}- ${cond.type}: "${escapeYamlString(cond.value)}"\n`;
                    yaml += `${currentIndent}  then:\n`;
                    currentIndent += '    ';
                }
                yaml += stepToYAMLInner(step, currentIndent);
                return yaml;
            }

            // Handle old single condition format (Step Model Redesign v1)
            if (step.condition?.enabled && step.condition.value) {
                const condType = step.condition.type;
                const condValue = step.condition.value;

                if (Array.isArray(condValue)) {
                    // Multi-element condition (if_all_present, if_any_present)
                    const elements = condValue.filter(v => v).map(v => `"${escapeYamlString(v)}"`).join(', ');
                    yaml = `${indent}- ${condType}: [${elements}]\n`;
                } else {
                    yaml = `${indent}- ${condType}: "${escapeYamlString(condValue)}"\n`;
                }
                yaml += `${indent}  then:\n`;
                yaml += stepToYAMLInner(step, indent + '    ');
                return yaml;
            }

            // Handle legacy conditional format
            if (step.conditional?.enabled && step.conditional.value) {
                yaml = `${indent}- ${step.conditional.type}: "${escapeYamlString(step.conditional.value)}"\n`;
                yaml += `${indent}  then:\n`;
                yaml += stepToYAMLInner(step, indent + '    ');
                return yaml;
            }

            return stepToYAMLInner(step, indent);
        }

        function stepToYAMLInner(step, indent) {
            let yaml = '';
            const analysis = step.analysis || {};

            // Add context comment from step title/analysis
            if (analysis.action) {
                yaml += `${indent}# ${analysis.action}\n`;
            }

            if (step.action === 'tap') {
                const x = step.target?.x || 0;
                const y = step.target?.y || 0;
                const xPct = toPercent(x, SCREEN_WIDTH);
                const yPct = toPercent(y, SCREEN_HEIGHT);
                const pctCoords = `["${xPct}%", "${yPct}%"]`;
                const elementText = step.target?.text;

                // Use element text as primary target for better readability and Claude understanding
                if (elementText && elementText.length > 0) {
                    yaml += `${indent}- tap: "${escapeYamlString(elementText)}"  # fallback: ${pctCoords}\n`;
                } else {
                    yaml += `${indent}- tap: ${pctCoords}\n`;
                }
                if (step.waitAfter > 0) {
                    yaml += `${indent}- wait: ${step.waitAfter}ms\n`;
                }
            } else if (step.action === 'long_press') {
                const x = step.target?.x || 0;
                const y = step.target?.y || 0;
                const xPct = toPercent(x, SCREEN_WIDTH);
                const yPct = toPercent(y, SCREEN_HEIGHT);
                const pctCoords = `["${xPct}%", "${yPct}%"]`;
                const elementText = step.target?.text;
                const duration = step.duration || 500;

                if (elementText && elementText.length > 0) {
                    yaml += `${indent}- long_press: {element: "${escapeYamlString(elementText)}", duration: ${duration}}  # fallback: ${pctCoords}\n`;
                } else {
                    yaml += `${indent}- long_press: {position: ${pctCoords}, duration: ${duration}}\n`;
                }
            } else if (step.action === 'double_tap') {
                const x = step.target?.x || 0;
                const y = step.target?.y || 0;
                const xPct = toPercent(x, SCREEN_WIDTH);
                const yPct = toPercent(y, SCREEN_HEIGHT);
                const pctCoords = `["${xPct}%", "${yPct}%"]`;
                const elementText = step.target?.text;

                if (elementText && elementText.length > 0) {
                    yaml += `${indent}- double_tap: "${escapeYamlString(elementText)}"  # fallback: ${pctCoords}\n`;
                } else {
                    yaml += `${indent}- double_tap: ${pctCoords}\n`;
                }
            } else if (step.action === 'swipe') {
                const dir = step.direction || 'up';
                const distance = step.distance || 400;
                // Only include distance if non-default
                if (distance !== 400) {
                    yaml += `${indent}- swipe: {direction: ${dir}, distance: ${distance}}\n`;
                } else {
                    yaml += `${indent}- swipe: ${dir}\n`;
                }
            } else if (step.action === 'type') {
                const text = step.text || step.target?.text || '';
                const submit = step.submit || false;
                if (submit) {
                    yaml += `${indent}- type: {text: "${escapeYamlString(text)}", submit: true}\n`;
                } else {
                    yaml += `${indent}- type: "${escapeYamlString(text)}"\n`;
                }
            } else if (step.action === 'verify_screen') {
                yaml += `${indent}- verify_screen: "${escapeYamlString(step.description || '')}"\n`;
            } else if (step.action === 'wait_for') {
                yaml += `${indent}- wait_for: "${escapeYamlString(step.target?.text || '')}"\n`;
            } else if (step.action === 'wait') {
                yaml += `${indent}- wait: ${step.duration}ms\n`;
            }

            // Add embedded verifications if present (Step Model Redesign v2 - array format)
            if (step.verifications && step.verifications.length > 0) {
                for (const ver of step.verifications) {
                    if (ver.description) {
                        yaml += `${indent}- verify_screen: "${escapeYamlString(ver.description)}"\n`;
                    }
                }
            }
            // Handle old single verification format (Step Model Redesign v1)
            else if (step.verification?.enabled && step.verification.description) {
                yaml += `${indent}- verify_screen: "${escapeYamlString(step.verification.description)}"\n`;
            }

            // Add suggested verification as comment if not yet added
            const hasVerifications = (step.verifications && step.verifications.length > 0) || step.verification?.enabled;
            if (step.suggestedVerification && !hasVerifications) {
                yaml += `${indent}# Suggested: verify_screen: "${escapeYamlString(step.suggestedVerification)}"\n`;
            }

            return yaml;
        }

        // Escape special characters for YAML double-quoted strings
        function escapeYamlString(str) {
            if (!str) return '';
            return String(str)
                .replace(/\\/g, '\\\\')
                .replace(/"/g, '\\"')
                .replace(/\n/g, '\\n')
                .replace(/\r/g, '\\r');
        }

        function downloadFile(filename, content) {
            const blob = new Blob([content], { type: 'text/yaml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function discardTest() {
            if (confirm('Discard this test recording? This cannot be undone.')) {
                window.close();
            }
        }

        // Position gesture indicator wrapper to match actual image bounds (accounting for object-fit: contain)
        function positionIndicator(img, stepId) {
            const wrapper = img.parentElement.querySelector(`.gesture-indicator-wrapper[data-step-id="${stepId}"]`);
            if (!wrapper) return;

            const containerWidth = img.parentElement.clientWidth;
            const containerHeight = img.parentElement.clientHeight;

            // Use getBoundingClientRect to get actual rendered image size
            const imgRect = img.getBoundingClientRect();
            const containerRect = img.parentElement.getBoundingClientRect();

            // Calculate offset relative to container
            const offsetX = imgRect.left - containerRect.left;
            const offsetY = imgRect.top - containerRect.top;

            // Position wrapper to match image bounds exactly
            wrapper.style.left = offsetX + 'px';
            wrapper.style.top = offsetY + 'px';
            wrapper.style.width = imgRect.width + 'px';
            wrapper.style.height = imgRect.height + 'px';

            // Position swipe trajectory if this is a swipe indicator
            const swipeIndicator = wrapper.querySelector('.swipe-indicator');
            if (swipeIndicator) {
                positionSwipeTrajectory(swipeIndicator, imgRect.width, imgRect.height);
            }
        }

        // Position swipe trajectory line and arrow based on actual rendered dimensions
        function positionSwipeTrajectory(swipeIndicator, wrapperWidth, wrapperHeight) {
            const startXPct = parseFloat(swipeIndicator.dataset.startX);
            const startYPct = parseFloat(swipeIndicator.dataset.startY);
            const endXPct = parseFloat(swipeIndicator.dataset.endX);
            const endYPct = parseFloat(swipeIndicator.dataset.endY);

            // Convert percentages to actual pixels
            const startXPx = (startXPct / 100) * wrapperWidth;
            const startYPx = (startYPct / 100) * wrapperHeight;
            const endXPx = (endXPct / 100) * wrapperWidth;
            const endYPx = (endYPct / 100) * wrapperHeight;

            // Calculate full distance and angle
            const dx = endXPx - startXPx;
            const dy = endYPx - startYPx;
            const lineLength = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx) * (180 / Math.PI);

            // Set CSS variables for trajectory line - full length
            const trajectoryLine = swipeIndicator.querySelector('.swipe-trajectory-line');
            if (trajectoryLine) {
                trajectoryLine.style.setProperty('--start-x', startXPx + 'px');
                trajectoryLine.style.setProperty('--start-y', startYPx + 'px');
                trajectoryLine.style.setProperty('--line-length', lineLength + 'px');
                trajectoryLine.style.setProperty('--line-angle', angle + 'deg');
            }
        }

        // Re-position indicators on window resize
        window.addEventListener('resize', function() {
            document.querySelectorAll('.gesture-indicator-wrapper').forEach(wrapper => {
                const stepId = wrapper.dataset.stepId;
                const img = wrapper.parentElement.querySelector('img');
                if (img && stepId) {
                    positionIndicator(img, stepId);
                }
            });
        });

        // Image Modal (simple version)
        function openModal(src) {
            const img = new Image();
            img.src = src;
            img.style.cssText = 'max-width: 90vw; max-height: 90vh; border-radius: 8px;';

            const overlay = document.createElement('div');
            overlay.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); display: flex; align-items: center; justify-content: center; z-index: 9999; cursor: pointer;';
            overlay.appendChild(img);
            overlay.onclick = () => overlay.remove();
            document.body.appendChild(overlay);
        }

        /* ============================================================
           CONDITION COMPONENT FUNCTIONS (Step Model Redesign)
           ============================================================ */

        /**
         * Toggle the expand/collapse state of a condition component.
         */
        function toggleCondition(stepId) {
            event.stopPropagation();
            const conditionDiv = document.querySelector(`.step-condition[data-step-id="${stepId}"]`);
            if (!conditionDiv) return;

            conditionDiv.classList.toggle('collapsed');

            // Update preview text when collapsing
            if (conditionDiv.classList.contains('collapsed')) {
                updateConditionPreview(stepId);
            }
        }

        /**
         * Update the condition type and re-render the value field.
         */
        function updateConditionType(stepId, newType) {
            event.stopPropagation();
            const step = steps.find(s => s.id === stepId);
            if (!step) return;

            // Ensure condition object exists
            if (!step.condition) {
                step.condition = { enabled: true, type: newType, value: '' };
            } else {
                step.condition.type = newType;
            }

            // Convert value format if needed
            if (newType === 'if_all_present' || newType === 'if_any_present') {
                if (!Array.isArray(step.condition.value)) {
                    step.condition.value = step.condition.value ? [step.condition.value] : [''];
                }
            } else {
                if (Array.isArray(step.condition.value)) {
                    step.condition.value = step.condition.value[0] || '';
                }
            }

            // Re-render the value input field
            renderConditionValueField(stepId);
        }

        /**
         * Update the condition value for single-value types.
         */
        function updateConditionValue(stepId, value) {
            event.stopPropagation();
            const step = steps.find(s => s.id === stepId);
            if (!step || !step.condition) return;

            step.condition.value = value;
        }

        /**
         * Update a specific element in a multi-element condition.
         */
        function updateConditionElement(stepId, index, value) {
            event.stopPropagation();
            const step = steps.find(s => s.id === stepId);
            if (!step || !step.condition || !Array.isArray(step.condition.value)) return;

            step.condition.value[index] = value;
        }

        /**
         * Add a new element to a multi-element condition.
         */
        function addConditionElement(stepId) {
            event.stopPropagation();
            const step = steps.find(s => s.id === stepId);
            if (!step || !step.condition) return;

            if (!Array.isArray(step.condition.value)) {
                step.condition.value = [];
            }

            step.condition.value.push('');
            renderConditionValueField(stepId);

            // Focus the new input
            setTimeout(() => {
                const list = document.getElementById(`condition-elements-${stepId}`);
                if (list) {
                    const inputs = list.querySelectorAll('input');
                    const lastInput = inputs[inputs.length - 1];
                    if (lastInput) lastInput.focus();
                }
            }, 50);
        }

        /**
         * Remove an element from a multi-element condition.
         */
        function removeConditionElement(stepId, index) {
            event.stopPropagation();
            const step = steps.find(s => s.id === stepId);
            if (!step || !step.condition || !Array.isArray(step.condition.value)) return;

            if (step.condition.value.length <= 1) return;

            step.condition.value.splice(index, 1);
            renderConditionValueField(stepId);
        }

        /**
         * Remove the condition from a step.
         */
        function removeCondition(stepId) {
            event.stopPropagation();
            if (!confirm('Remove this condition?')) return;

            const step = steps.find(s => s.id === stepId);
            if (step) {
                step.condition = null;
            }
            renderSteps();
        }

        /**
         * Show the add condition form.
         */
        function showAddConditionForm(stepId) {
            event.stopPropagation();
            const step = steps.find(s => s.id === stepId);
            if (!step) return;

            step._addingCondition = true;
            renderSteps();

            // Focus the input after render
            setTimeout(() => {
                const input = document.getElementById(`condition-value-input-${stepId}`);
                if (input) input.focus();
            }, 50);
        }

        /**
         * Cancel adding a condition.
         */
        function cancelAddCondition(stepId) {
            event.stopPropagation();
            const step = steps.find(s => s.id === stepId);
            if (!step) return;

            step._addingCondition = false;
            renderSteps();
        }

        /**
         * Confirm and add the condition to the step.
         */
        function confirmAddCondition(stepId) {
            event.stopPropagation();
            const step = steps.find(s => s.id === stepId);
            if (!step) return;

            const typeSelect = document.getElementById(`condition-type-${stepId}`);
            const valueInput = document.getElementById(`condition-value-input-${stepId}`);

            const type = typeSelect?.value || 'if_present';
            const value = valueInput?.value?.trim() || '';

            if (!value) {
                alert('Please enter a value for the condition');
                return;
            }

            // Initialize conditions array if needed
            if (!step.conditions) {
                step.conditions = [];
            }

            // Add the new condition
            step.conditions.push({ type, value });
            step._addingCondition = false;

            renderSteps();
        }

        /**
         * Remove a condition from the step.
         */
        function removeConditionFromStep(stepId, index) {
            event.stopPropagation();
            const step = steps.find(s => s.id === stepId);
            if (!step || !step.conditions) return;

            step.conditions.splice(index, 1);
            renderSteps();
        }

        /**
         * Legacy: Add a condition to a step (old format).
         */
        function addConditionToStep(stepId) {
            showAddConditionForm(stepId);
        }

        /**
         * Render the condition value input field based on type.
         */
        function renderConditionValueField(stepId) {
            const step = steps.find(s => s.id === stepId);
            if (!step || !step.condition) return;

            const valueField = document.getElementById(`condition-value-${stepId}`);
            if (!valueField) return;

            const type = step.condition.type;
            const value = step.condition.value;

            if (type === 'if_all_present' || type === 'if_any_present') {
                const labelText = type === 'if_all_present'
                    ? 'Elements (all must be present):'
                    : 'Elements (any must be present):';
                const elements = Array.isArray(value) ? value : [value || ''];

                valueField.innerHTML = `
                    <label style="margin-bottom: 6px;">${labelText}</label>
                    <div class="condition-elements-list" id="condition-elements-${stepId}">
                        ${elements.map((el, i) => `
                            <div class="condition-element-row" data-index="${i}">
                                <input type="text" value="${escapeHtml(el)}" onchange="updateConditionElement('${stepId}', ${i}, this.value)" onclick="event.stopPropagation()">
                                <button class="condition-element-remove" onclick="removeConditionElement('${stepId}', ${i})" title="Remove">&times;</button>
                            </div>
                        `).join('')}
                    </div>
                    <button class="condition-add-element" onclick="addConditionElement('${stepId}')">+ Add Element</button>
                `;
                valueField.style.flexDirection = 'column';
                valueField.style.alignItems = 'flex-start';
            } else if (type === 'if_screen') {
                valueField.innerHTML = `
                    <label>Value:</label>
                    <input type="text" placeholder="Describe expected screen state..." value="${escapeHtml(value || '')}" onchange="updateConditionValue('${stepId}', this.value)" onclick="event.stopPropagation()" style="min-width: 280px;">
                `;
                valueField.style.flexDirection = 'row';
                valueField.style.alignItems = 'center';
            } else {
                valueField.innerHTML = `
                    <label>Value:</label>
                    <input type="text" placeholder="Element text or label..." value="${escapeHtml(value || '')}" onchange="updateConditionValue('${stepId}', this.value)" onclick="event.stopPropagation()">
                `;
                valueField.style.flexDirection = 'row';
                valueField.style.alignItems = 'center';
            }
        }

        /**
         * Update the preview text for a collapsed condition.
         */
        function updateConditionPreview(stepId) {
            const step = steps.find(s => s.id === stepId);
            if (!step || !step.condition) return;

            const preview = document.querySelector(`.step-condition[data-step-id="${stepId}"] .condition-preview`);
            if (!preview) return;

            const type = step.condition.type;
            const value = step.condition.value;

            let previewText = `${type}: `;
            if (Array.isArray(value)) {
                previewText += value.filter(v => v).join(', ');
            } else {
                previewText += `"${value || ''}"`;
            }

            preview.textContent = previewText;
        }

        /**
         * Render condition component HTML.
         */
        function renderConditionComponent(step) {
            if (!step.condition || !step.condition.enabled) {
                return '';
            }

            const type = step.condition.type;
            const value = step.condition.value;
            let previewText = `${type}: `;
            if (Array.isArray(value)) {
                previewText += value.filter(v => v).slice(0, 2).join(', ');
                if (value.length > 2) previewText += '...';
            } else {
                previewText += `"${(value || '').substring(0, 20)}${(value || '').length > 20 ? '...' : ''}"`;
            }

            // Determine value field HTML
            let valueFieldHtml = '';
            if (type === 'if_all_present' || type === 'if_any_present') {
                const elements = Array.isArray(value) ? value : [value || ''];
                const labelText = type === 'if_all_present'
                    ? 'Elements (all must be present):'
                    : 'Elements (any must be present):';
                valueFieldHtml = `
                    <div class="condition-field" id="condition-value-${step.id}" style="flex-direction: column; align-items: flex-start;">
                        <label style="margin-bottom: 6px;">${labelText}</label>
                        <div class="condition-elements-list" id="condition-elements-${step.id}">
                            ${elements.map((el, i) => `
                                <div class="condition-element-row" data-index="${i}">
                                    <input type="text" value="${escapeHtml(el)}" onchange="updateConditionElement('${step.id}', ${i}, this.value)" onclick="event.stopPropagation()">
                                    <button class="condition-element-remove" onclick="removeConditionElement('${step.id}', ${i})" title="Remove">&times;</button>
                                </div>
                            `).join('')}
                        </div>
                        <button class="condition-add-element" onclick="addConditionElement('${step.id}')">+ Add Element</button>
                    </div>
                `;
            } else if (type === 'if_screen') {
                valueFieldHtml = `
                    <div class="condition-field" id="condition-value-${step.id}">
                        <label>Value:</label>
                        <input type="text" placeholder="Describe expected screen state..." value="${escapeHtml(value || '')}" onchange="updateConditionValue('${step.id}', this.value)" onclick="event.stopPropagation()" style="min-width: 280px;">
                    </div>
                `;
            } else {
                valueFieldHtml = `
                    <div class="condition-field" id="condition-value-${step.id}">
                        <label>Value:</label>
                        <input type="text" placeholder="Element text or label..." value="${escapeHtml(value || '')}" onchange="updateConditionValue('${step.id}', this.value)" onclick="event.stopPropagation()">
                    </div>
                `;
            }

            return `
                <div class="step-condition collapsed" data-step-id="${step.id}">
                    <div class="condition-header" onclick="toggleCondition('${step.id}')">
                        <span class="condition-label">
                            <span class="material-symbols-outlined">bolt</span> CONDITION
                            <span class="condition-expand-hint">(click to expand)</span>
                            <span class="condition-preview">${escapeHtml(previewText)}</span>
                        </span>
                        <button class="condition-remove-btn" onclick="removeCondition('${step.id}')" title="Remove condition">&times;</button>
                    </div>
                    <div class="condition-body">
                        <div class="condition-field">
                            <label>Type:</label>
                            <select onchange="updateConditionType('${step.id}', this.value)" onclick="event.stopPropagation()">
                                <option value="if_present" ${type === 'if_present' ? 'selected' : ''}>if_present</option>
                                <option value="if_absent" ${type === 'if_absent' ? 'selected' : ''}>if_absent</option>
                                <option value="if_screen" ${type === 'if_screen' ? 'selected' : ''}>if_screen</option>
                                <option value="if_all_present" ${type === 'if_all_present' ? 'selected' : ''}>if_all_present</option>
                                <option value="if_any_present" ${type === 'if_any_present' ? 'selected' : ''}>if_any_present</option>
                            </select>
                        </div>
                        ${valueFieldHtml}
                    </div>
                </div>
            `;
        }

        /* ============================================================
           VERIFICATION COMPONENT FUNCTIONS (Step Model Redesign)
           ============================================================ */

        /**
         * Toggle the expand/collapse state of a verification component.
         */
        function toggleVerification(stepId) {
            event.stopPropagation();
            const verificationDiv = document.querySelector(`.step-verification[data-step-id="${stepId}"]`);
            if (!verificationDiv) return;

            verificationDiv.classList.toggle('collapsed');

            if (verificationDiv.classList.contains('collapsed')) {
                updateVerificationPreview(stepId);
            }
        }

        /**
         * Update the verification description.
         */
        function updateVerificationDescription(stepId, value) {
            event.stopPropagation();
            const step = steps.find(s => s.id === stepId);
            if (!step) return;

            if (!step.verification) {
                step.verification = { enabled: true, description: value };
            } else {
                step.verification.description = value;
            }
        }

        /**
         * Remove the verification from a step.
         */
        function removeVerification(stepId) {
            event.stopPropagation();
            if (!confirm('Remove this verification?')) return;

            const step = steps.find(s => s.id === stepId);
            if (step) {
                step.verification = null;
            }
            renderSteps();
        }

        /**
         * Show the add verification form.
         */
        function showAddVerificationForm(stepId) {
            event.stopPropagation();
            const step = steps.find(s => s.id === stepId);
            if (!step) return;

            step._addingVerification = true;
            renderSteps();

            // Focus the input after render and pre-fill with suggestion
            setTimeout(() => {
                const input = document.getElementById(`verification-value-input-${stepId}`);
                if (input) {
                    input.value = step.suggestedVerification || '';
                    input.focus();
                }
            }, 50);
        }

        /**
         * Cancel adding a verification.
         */
        function cancelAddVerification(stepId) {
            event.stopPropagation();
            const step = steps.find(s => s.id === stepId);
            if (!step) return;

            step._addingVerification = false;
            renderSteps();
        }

        /**
         * Confirm and add the verification to the step.
         */
        function confirmAddVerification(stepId) {
            event.stopPropagation();
            const step = steps.find(s => s.id === stepId);
            if (!step) return;

            const valueInput = document.getElementById(`verification-value-input-${stepId}`);
            const description = valueInput?.value?.trim() || '';

            if (!description) {
                alert('Please enter a verification description');
                return;
            }

            // Initialize verifications array if needed
            if (!step.verifications) {
                step.verifications = [];
            }

            // Add the new verification
            step.verifications.push({ description });
            step._addingVerification = false;

            renderSteps();
        }

        /**
         * Remove a verification from the step.
         */
        function removeVerificationFromStep(stepId, index) {
            event.stopPropagation();
            const step = steps.find(s => s.id === stepId);
            if (!step || !step.verifications) return;

            step.verifications.splice(index, 1);
            renderSteps();
        }

        /**
         * Legacy: Add a verification to a step.
         */
        function addVerificationToStep(stepId) {
            showAddVerificationForm(stepId);
        }

        /**
         * Update the preview text for a collapsed verification.
         */
        function updateVerificationPreview(stepId) {
            const step = steps.find(s => s.id === stepId);
            if (!step || !step.verification) return;

            const preview = document.querySelector(`.step-verification[data-step-id="${stepId}"] .verification-preview`);
            if (!preview) return;

            const desc = step.verification.description || '';
            const truncated = desc.length > 30 ? desc.substring(0, 30) + '...' : desc;
            preview.textContent = `"${truncated}"`;
        }

        /**
         * Render verification component HTML.
         */
        function renderVerificationComponent(step) {
            if (!step.verification || !step.verification.enabled) {
                return '';
            }

            const desc = step.verification.description || '';
            const truncated = desc.length > 30 ? desc.substring(0, 30) + '...' : desc;

            return `
                <div class="step-verification collapsed" data-step-id="${step.id}">
                    <div class="verification-header" onclick="toggleVerification('${step.id}')">
                        <span class="verification-label">
                            <span class="material-symbols-outlined">check</span> VERIFICATION
                            <span class="verification-expand-hint">(click to expand)</span>
                            <span class="verification-preview">"${escapeHtml(truncated)}"</span>
                        </span>
                        <button class="verification-remove-btn" onclick="removeVerification('${step.id}')" title="Remove verification">&times;</button>
                    </div>
                    <div class="verification-body">
                        <div class="verification-hint">Assert on AFTER frame:</div>
                        <textarea class="verification-textarea"
                                  placeholder="Describe what the screen should show after this action..."
                                  onchange="updateVerificationDescription('${step.id}', this.value)"
                                  onclick="event.stopPropagation()">${escapeHtml(desc)}</textarea>
                    </div>
                </div>
            `;
        }

        /**
         * Render add buttons for condition/verification.
         */
        function renderAddButtons(step) {
            const hasCondition = step.condition && step.condition.enabled;
            const hasVerification = step.verification && step.verification.enabled;

            if (hasCondition && hasVerification) {
                return '';
            }

            return `
                <div class="step-add-buttons" style="display: flex; gap: 8px; margin-top: 12px;">
                    ${!hasCondition ? `<button class="btn-add-condition" onclick="addConditionToStep('${step.id}')">+ Condition</button>` : ''}
                    ${!hasVerification ? `<button class="btn-add-verification" onclick="addVerificationToStep('${step.id}')">+ Verification</button>` : ''}
                </div>
            `;
        }

        /* ============================================================
           VIDEO PICKER MODAL FUNCTIONS (Step Model Redesign)
           ============================================================ */

        // Video picker state
        let videoPickerState = {
            isOpen: false,
            frameType: 'BEFORE',  // BEFORE, ACTION, AFTER
            stepId: null,
            callback: null,
            position: null  // { x, y } in normalized coordinates (0-1)
        };

        /**
         * Open the video picker modal.
         */
        function openVideoPicker(stepId, frameType, callback) {
            videoPickerState = {
                isOpen: true,
                frameType: frameType,
                stepId: stepId,
                callback: callback,
                position: null
            };

            // Set frame type badge
            const badge = document.getElementById('videoPickerFrameType');
            badge.textContent = frameType;
            badge.className = 'frame-type-badge ' + frameType.toLowerCase();

            // Update instruction based on frame type
            const instruction = document.getElementById('videoPickerInstruction');
            if (frameType === 'ACTION') {
                instruction.textContent = 'Click on the video to place tap position, then click Capture';
                instruction.classList.add('highlight');
            } else {
                instruction.textContent = 'Scrub to the desired moment and click Capture';
                instruction.classList.remove('highlight');
            }

            // Show/hide overlay and position info
            const overlay = document.getElementById('videoPickerOverlay');
            const positionInfo = document.getElementById('videoPickerPositionInfo');
            if (frameType === 'ACTION') {
                overlay.classList.add('active');
                positionInfo.classList.remove('active');
            } else {
                overlay.classList.remove('active');
                positionInfo.classList.remove('active');
            }

            // Clear position indicator
            const indicator = document.getElementById('videoPickerTapIndicator');
            indicator.classList.remove('visible');

            // Clear description
            document.getElementById('videoPickerDescription').value = '';

            // Set video source and sync with main video
            const mainVideo = document.getElementById('video');
            const pickerVideo = document.getElementById('videoPickerVideo');
            pickerVideo.src = mainVideo.src;
            pickerVideo.currentTime = mainVideo.currentTime;

            // Setup video events
            setupVideoPickerEvents();

            // Show modal
            document.getElementById('videoPickerBackdrop').classList.add('active');
            document.body.style.overflow = 'hidden';
        }

        /**
         * Close the video picker modal.
         */
        function closeVideoPicker(event) {
            if (event && event.target !== event.currentTarget) return;

            videoPickerState.isOpen = false;
            document.getElementById('videoPickerBackdrop').classList.remove('active');
            document.body.style.overflow = '';

            // Pause video
            const pickerVideo = document.getElementById('videoPickerVideo');
            pickerVideo.pause();
        }

        /**
         * Setup video picker events.
         */
        function setupVideoPickerEvents() {
            const video = document.getElementById('videoPickerVideo');
            const scrubber = document.getElementById('videoPickerScrubber');
            const playBtn = document.getElementById('videoPickerPlayBtn');
            const timeDisplay = document.getElementById('videoPickerTime');

            // Update time display
            function updateTime() {
                const current = formatTime(video.currentTime);
                const duration = formatTime(video.duration || 0);
                timeDisplay.textContent = `${current} / ${duration}`;
            }

            // Update scrubber
            video.ontimeupdate = function() {
                if (video.duration) {
                    scrubber.value = (video.currentTime / video.duration) * 100;
                }
                updateTime();
            };

            // Handle scrubber change
            scrubber.oninput = function() {
                if (video.duration) {
                    video.currentTime = (scrubber.value / 100) * video.duration;
                }
                updateTime();
            };

            // Handle play/pause
            video.onplay = function() {
                playBtn.textContent = '⏸';
            };
            video.onpause = function() {
                playBtn.textContent = '▶';
            };

            // Update on load
            video.onloadedmetadata = function() {
                updateTime();
            };
        }

        /**
         * Toggle video picker play/pause.
         */
        function toggleVideoPickerPlay() {
            const video = document.getElementById('videoPickerVideo');
            if (video.paused) {
                video.play();
            } else {
                video.pause();
            }
        }

        /**
         * Handle click on video for tap position (ACTION frame).
         */
        function handleVideoPickerClick(event) {
            if (videoPickerState.frameType !== 'ACTION') return;

            const video = document.getElementById('videoPickerVideo');
            const overlay = document.getElementById('videoPickerOverlay');
            const indicator = document.getElementById('videoPickerTapIndicator');

            // Get video dimensions and position
            const videoRect = video.getBoundingClientRect();
            const overlayRect = overlay.getBoundingClientRect();

            // Calculate click position relative to video
            const clickX = event.clientX - overlayRect.left;
            const clickY = event.clientY - overlayRect.top;

            // Account for letterboxing (video might be smaller than container)
            const videoAspect = video.videoWidth / video.videoHeight;
            const containerAspect = overlayRect.width / overlayRect.height;

            let videoDisplayWidth, videoDisplayHeight, offsetX, offsetY;

            if (videoAspect > containerAspect) {
                // Video is wider - letterbox top/bottom
                videoDisplayWidth = overlayRect.width;
                videoDisplayHeight = overlayRect.width / videoAspect;
                offsetX = 0;
                offsetY = (overlayRect.height - videoDisplayHeight) / 2;
            } else {
                // Video is taller - letterbox left/right
                videoDisplayHeight = overlayRect.height;
                videoDisplayWidth = overlayRect.height * videoAspect;
                offsetX = (overlayRect.width - videoDisplayWidth) / 2;
                offsetY = 0;
            }

            // Check if click is within video bounds
            if (clickX < offsetX || clickX > offsetX + videoDisplayWidth ||
                clickY < offsetY || clickY > offsetY + videoDisplayHeight) {
                return; // Click was on letterbox, not video
            }

            // Calculate normalized position (0-1)
            const normalizedX = (clickX - offsetX) / videoDisplayWidth;
            const normalizedY = (clickY - offsetY) / videoDisplayHeight;

            // Store position
            videoPickerState.position = { x: normalizedX, y: normalizedY };

            // Position indicator
            indicator.style.left = clickX + 'px';
            indicator.style.top = clickY + 'px';
            indicator.classList.add('visible');

            // Update position info
            const positionInfo = document.getElementById('videoPickerPositionInfo');
            document.getElementById('videoPickerCoordX').textContent = Math.round(normalizedX * 100) + '%';
            document.getElementById('videoPickerCoordY').textContent = Math.round(normalizedY * 100) + '%';
            positionInfo.classList.add('active');
        }

        /**
         * Clear the tap position in video picker.
         */
        function clearVideoPickerPosition() {
            videoPickerState.position = null;
            document.getElementById('videoPickerTapIndicator').classList.remove('visible');
            document.getElementById('videoPickerPositionInfo').classList.remove('active');
        }

        /**
         * Capture the current frame from video picker.
         */
        function captureVideoPickerFrame() {
            const video = document.getElementById('videoPickerVideo');
            const description = document.getElementById('videoPickerDescription').value;

            // Create canvas to capture frame
            const canvas = document.createElement('canvas');
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(video, 0, 0);

            // Get frame as data URL
            const frameDataUrl = canvas.toDataURL('image/png');

            // Build result
            const result = {
                frameType: videoPickerState.frameType,
                timestamp: video.currentTime,
                image: frameDataUrl,
                description: description
            };

            // Include position for ACTION frames
            if (videoPickerState.frameType === 'ACTION' && videoPickerState.position) {
                result.position = {
                    x: Math.round(videoPickerState.position.x * SCREEN_WIDTH),
                    y: Math.round(videoPickerState.position.y * SCREEN_HEIGHT),
                    xPercent: Math.round(videoPickerState.position.x * 100),
                    yPercent: Math.round(videoPickerState.position.y * 100)
                };
            }

            // Call callback
            if (videoPickerState.callback) {
                videoPickerState.callback(result);
            }

            // Close modal
            closeVideoPicker();
        }

        /**
         * Open video picker for a specific frame in a step.
         */
        function openFrameVideoPicker(stepId, frameType) {
            event.stopPropagation();

            openVideoPicker(stepId, frameType, function(result) {
                const step = steps.find(s => s.id === stepId);
                if (!step) return;

                // Ensure frames object exists
                if (!step.frames) {
                    step.frames = {};
                }

                // Handle new frame structure
                if (frameType === 'BEFORE') {
                    step.frames.before = result.image;
                    if (result.description) {
                        if (!step.analysis) step.analysis = {};
                        step.analysis.before = result.description;
                    }
                } else if (frameType === 'ACTION') {
                    step.frames.action = result.image;
                    if (result.position) {
                        if (!step.target) step.target = {};
                        step.target.x = result.position.x;
                        step.target.y = result.position.y;
                    }
                    if (result.description) {
                        if (!step.analysis) step.analysis = {};
                        step.analysis.action = result.description;
                    }
                } else if (frameType === 'AFTER') {
                    step.frames.after = result.image;
                    if (result.description) {
                        if (!step.analysis) step.analysis = {};
                        step.analysis.after = result.description;
                    }
                }

                renderSteps();
            });
        }

        // Keyboard shortcuts for video picker
        document.addEventListener('keydown', function(event) {
            if (!videoPickerState.isOpen) return;

            const video = document.getElementById('videoPickerVideo');

            switch (event.key) {
                case 'Escape':
                    closeVideoPicker();
                    break;
                case ' ':
                    event.preventDefault();
                    toggleVideoPickerPlay();
                    break;
                case 'ArrowLeft':
                    event.preventDefault();
                    video.currentTime = Math.max(0, video.currentTime - 1);
                    break;
                case 'ArrowRight':
                    event.preventDefault();
                    video.currentTime = Math.min(video.duration, video.currentTime + 1);
                    break;
                case 'Enter':
                    event.preventDefault();
                    captureVideoPickerFrame();
                    break;
            }
        });
    </script>

    <!-- Video Picker Modal (Step Model Redesign) -->
    <div id="videoPickerBackdrop" class="video-picker-backdrop" onclick="closeVideoPicker(event)">
        <div class="video-picker-modal" onclick="event.stopPropagation()">
            <div class="video-picker-header">
                <div class="video-picker-title">
                    Select <span id="videoPickerFrameType" class="frame-type-badge">BEFORE</span> Frame
                </div>
                <button class="video-picker-close" onclick="closeVideoPicker()" title="Close (Esc)">&times;</button>
            </div>
            <div class="video-picker-body">
                <div class="video-picker-video-container">
                    <video id="videoPickerVideo" class="video-picker-video"></video>
                    <div id="videoPickerOverlay" class="video-picker-overlay" onclick="handleVideoPickerClick(event)">
                        <div id="videoPickerTapIndicator" class="video-picker-tap-indicator"></div>
                    </div>
                </div>

                <div id="videoPickerInstruction" class="video-picker-instruction">
                    Scrub to the desired moment and click Capture
                </div>

                <div class="video-picker-controls">
                    <button id="videoPickerPlayBtn" class="video-picker-play-btn" onclick="toggleVideoPickerPlay()">▶</button>
                    <input type="range" id="videoPickerScrubber" class="video-picker-scrubber" min="0" max="100" value="0" step="0.01">
                    <span id="videoPickerTime" class="video-picker-time">0:00 / 0:00</span>
                </div>

                <div id="videoPickerPositionInfo" class="video-picker-position-info">
                    <div class="video-picker-position-coords">
                        <div class="video-picker-coord">
                            <span class="video-picker-coord-label">X:</span>
                            <span id="videoPickerCoordX" class="video-picker-coord-value">50%</span>
                        </div>
                        <div class="video-picker-coord">
                            <span class="video-picker-coord-label">Y:</span>
                            <span id="videoPickerCoordY" class="video-picker-coord-value">50%</span>
                        </div>
                    </div>
                    <button class="video-picker-clear-position" onclick="clearVideoPickerPosition()">Clear Position</button>
                </div>

                <div class="video-picker-description-section">
                    <label class="video-picker-description-label">Description (optional)</label>
                    <input type="text" id="videoPickerDescription" class="video-picker-description-input" placeholder="Describe this screen state...">
                </div>
            </div>
            <div class="video-picker-footer">
                <button class="video-picker-btn video-picker-btn-cancel" onclick="closeVideoPicker()">Cancel</button>
                <button id="videoPickerCaptureBtn" class="video-picker-btn video-picker-btn-capture" onclick="captureVideoPickerFrame()">Capture</button>
            </div>
        </div>
    </div>

    <!-- MD3 Custom Input Dialog -->
    <div id="md3DialogOverlay" class="md3-dialog-overlay" onclick="closeMd3Dialog()">
        <div class="md3-dialog" onclick="event.stopPropagation()">
            <div class="md3-dialog-header">
                <h2 id="md3DialogTitle" class="md3-dialog-title">Edit</h2>
            </div>
            <div class="md3-dialog-content">
                <div class="md3-text-field">
                    <textarea id="md3DialogInput" class="md3-text-field-input" rows="3" placeholder=" "></textarea>
                    <label id="md3DialogLabel" class="md3-text-field-label">Value</label>
                </div>
            </div>
            <div class="md3-dialog-actions">
                <button class="md3-btn md3-btn-text" onclick="closeMd3Dialog()">Cancel</button>
                <button class="md3-btn md3-btn-filled" onclick="confirmMd3Dialog()">Save</button>
            </div>
        </div>
    </div>

    <script>
        // MD3 Custom Dialog System
        let md3DialogCallback = null;

        function showMd3Dialog(title, label, currentValue, callback) {
            const overlay = document.getElementById('md3DialogOverlay');
            const titleEl = document.getElementById('md3DialogTitle');
            const labelEl = document.getElementById('md3DialogLabel');
            const inputEl = document.getElementById('md3DialogInput');

            titleEl.textContent = title;
            labelEl.textContent = label;
            inputEl.value = currentValue || '';
            md3DialogCallback = callback;

            overlay.classList.add('open');
            // Focus input after animation
            setTimeout(() => inputEl.focus(), 100);

            // Handle Enter key
            inputEl.onkeydown = (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    confirmMd3Dialog();
                } else if (e.key === 'Escape') {
                    closeMd3Dialog();
                }
            };
        }

        function closeMd3Dialog() {
            const overlay = document.getElementById('md3DialogOverlay');
            overlay.classList.remove('open');
            md3DialogCallback = null;
        }

        function confirmMd3Dialog() {
            const inputEl = document.getElementById('md3DialogInput');
            const value = inputEl.value;
            if (md3DialogCallback && value !== null) {
                md3DialogCallback(value);
            }
            closeMd3Dialog();
        }

        // Helper function to replace prompt() calls
        function md3Prompt(title, label, currentValue) {
            return new Promise((resolve) => {
                showMd3Dialog(title, label, currentValue, (value) => {
                    resolve(value);
                });
            });
        }
    </script>

    <style>
        /* MD3 Dialog Styles */
        .md3-dialog-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(4px);
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease, visibility 0.2s ease;
        }

        .md3-dialog-overlay.open {
            opacity: 1;
            visibility: visible;
        }

        .md3-dialog {
            background: var(--md-surface-container-high, #2d2d2d);
            border-radius: 28px;
            min-width: 320px;
            max-width: 560px;
            width: 90%;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            transform: scale(0.9) translateY(20px);
            opacity: 0;
            transition: transform 0.25s cubic-bezier(0.05, 0.7, 0.1, 1), opacity 0.2s ease;
        }

        .md3-dialog-overlay.open .md3-dialog {
            transform: scale(1) translateY(0);
            opacity: 1;
        }

        .md3-dialog-header {
            padding: 24px 24px 0;
        }

        .md3-dialog-title {
            font-size: 1.5rem;
            font-weight: 400;
            color: var(--md-on-surface, #e6e1e5);
            margin: 0;
            line-height: 1.3;
        }

        .md3-dialog-content {
            padding: 16px 24px 24px;
        }

        .md3-text-field {
            position: relative;
            width: 100%;
        }

        .md3-text-field-input {
            width: 100%;
            min-height: 56px;
            padding: 24px 16px 8px;
            background: var(--md-surface-container-highest, #3d3d3d);
            border: none;
            border-bottom: 2px solid var(--md-outline, #938f99);
            border-radius: 4px 4px 0 0;
            font-size: 1rem;
            color: var(--md-on-surface, #e6e1e5);
            resize: vertical;
            font-family: inherit;
            line-height: 1.5;
            transition: border-color 0.2s ease;
        }

        .md3-text-field-input:focus {
            outline: none;
            border-bottom-color: var(--md-primary, #d0bcff);
        }

        .md3-text-field-label {
            position: absolute;
            left: 16px;
            top: 16px;
            font-size: 1rem;
            color: var(--md-on-surface-variant, #cac4d0);
            pointer-events: none;
            transition: all 0.2s ease;
        }

        .md3-text-field-input:focus + .md3-text-field-label,
        .md3-text-field-input:not(:placeholder-shown) + .md3-text-field-label {
            top: 8px;
            font-size: 0.75rem;
            color: var(--md-primary, #d0bcff);
        }

        .md3-dialog-actions {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            padding: 0 24px 24px;
        }

        .md3-btn {
            padding: 10px 24px;
            border-radius: 100px;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s ease;
            border: none;
        }

        .md3-btn-text {
            background: transparent;
            color: var(--md-primary, #d0bcff);
        }

        .md3-btn-text:hover {
            background: rgba(208, 188, 255, 0.08);
        }

        .md3-btn-filled {
            background: var(--md-primary, #d0bcff);
            color: var(--md-on-primary, #381e72);
        }

        .md3-btn-filled:hover {
            background: #e0d0ff;
            box-shadow: 0 2px 8px rgba(208, 188, 255, 0.3);
        }
    </style>
</body>
</html>
